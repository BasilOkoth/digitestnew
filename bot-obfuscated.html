<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Deriv DigitMatchStar Bot</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>

/* --- Compact responsive controls --- */
.sound-icon-btn{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:34px;
  height:30px;
  padding:0;
  border-radius:9999px;
  border:1px solid rgba(148,163,184,0.35);
  background:rgba(30,41,59,0.6);
  color:#e2e8f0;
  font-size:16px;
  line-height:1;
  transition:transform .05s ease, background .15s ease, border-color .15s ease;
}
.sound-icon-btn:hover{ background:rgba(30,41,59,0.85); border-color:rgba(148,163,184,0.55); }
.sound-icon-btn:active{ transform:scale(0.97); }
.sound-icon-btn:focus{ outline:none; box-shadow:0 0 0 3px rgba(59,130,246,0.25); }

.controls-wrap { max-width: 100%; }
.control-btn{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:.5rem;
  padding:.55rem .9rem;
  border-radius:9999px;
  font-weight:700;
  font-size:.9rem;
  line-height:1;
  color:#fff;
  box-shadow: 0 6px 18px rgba(0,0,0,.18);
  transition: transform .06s ease, filter .15s ease, opacity .15s ease;
  white-space:nowrap;
}
.control-btn:active{ transform: scale(.99); }
.control-btn:hover{ filter: brightness(1.02); }
@media (min-width: 640px){
  .control-btn{ padding:.45rem .8rem; font-size:.85rem; }
}
/* Make account toggle compact */
.account-toggle-container{ display:inline-flex; align-items:center; gap:.5rem; flex-wrap:nowrap; }
.account-label{ font-size:.8rem; font-weight:800; letter-spacing:.02em; opacity:.9; }
@media (max-width: 639px){
  .account-toggle-container{ justify-content:flex-start; }
}

        
/* --- Status indicators (non-clickable) --- */
.status-chip{
  display:inline-flex;
  align-items:center;
  gap:.45rem;
  padding:.40rem .70rem;
  border-radius:9999px;
  font-weight:800;
  font-size:.78rem;
  line-height:1;
  background:#1f2937;
  border:1px solid rgba(255,255,255,.12);
  color:#e5e7eb;
  user-select:none;
}
.status-dot{
  width:.55rem;
  height:.55rem;
  border-radius:9999px;
  background:#22c55e;
  box-shadow:0 0 0 3px rgba(34,197,94,.16);
}
.status-chip.off .status-dot{
  background:#ef4444;
  box-shadow:0 0 0 3px rgba(239,68,68,.16);
}
.status-icon{ font-size:.95rem; line-height:1; }
@media (max-width: 360px){
  .status-label{ display:none; }
}
#log-area::-webkit-scrollbar { width: 4px; }
        #log-area::-webkit-scrollbar-thumb { background: #4ade80; border-radius: 2px; }
        #log-area::-webkit-scrollbar-track { background: #374151; }
        body { font-family: 'Inter', sans-serif; background-color: #111827; }
        @keyframes pulse-once { 0% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.03); opacity: 0.9; } 100% { transform: scale(1); opacity: 1; } }
        .tick-flash { animation: pulse-once 0.1s ease-out; }
        @keyframes win-pulse { 
            0% { 
                box-shadow: 0 0 5px #10B981, 0 0 10px rgba(16, 185, 129, 0.5); 
                border-color: #10B981;
                background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.2)) !important;
            } 
            50% { 
                box-shadow: 0 0 30px #10B981, 0 0 50px rgba(16, 185, 129, 0.8); 
                border-color: #34d399;
                background: linear-gradient(135deg, rgba(16, 185, 129, 0.3), rgba(16, 185, 129, 0.4)) !important;
            } 
            100% { 
                box-shadow: 0 0 5px #10B981, 0 0 10px rgba(16, 185, 129, 0.5); 
                border-color: #10B981;
                background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.2)) !important;
            } 
        }
        .win-glow {
            animation: win-pulse 1s infinite;
        }
        .pnl-update-animation {
            animation: pnl-pulse 0.5s ease-in-out;
        }
        @keyframes pnl-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .contract-type-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 5px;
        }
        .stop-button-active {
            background-color: #dc2626 !important;
            border: 2px solid #fca5a5 !important;
            animation: pulse-once 0.5s infinite;
        }
        .start-button-active {
            background-color: #16a34a !important;
            border: 2px solid #86efac !important;
            animation: pulse-once 0.5s;
        }
        .analysis-active {
            border: 2px solid #00ffea !important;
            box-shadow: 0 0 10px rgba(0, 255, 234, 0.3) !important;
        }
        .analysis-complete {
            border: 2px solid #10b981 !important;
            background-color: #064e3b20 !important;
        }
        .connection-badge-connected {
            background: linear-gradient(90deg, #10b981, #059669) !important;
        }
        .connection-badge-disconnected {
            background: linear-gradient(90deg, #dc2626, #b91c1c) !important;
        }
        .connection-badge-connecting {
            background: linear-gradient(90deg, #f59e0b, #d97706) !important;
        }
        .account-toggle-container {
            display: inline-flex;
            align-items: center;
            margin-left: 15px;
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 10px;
            border-radius: 20px;
        }
        .account-toggle {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 22px;
            margin: 0 8px;
        }
        .account-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .account-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #1e40af;
            border-radius: 34px;
            transition: .4s;
        }
        .account-toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: .4s;
        }
        input:checked + .account-toggle-slider {
            background-color: #059669;
        }
        input:checked + .account-toggle-slider:before {
            transform: translateX(22px);
        }
        .account-label {
            font-size: 12px;
            font-weight: 600;
        }
        .account-label-demo {
            color: #3b82f6;
        }
        .account-label-real {
            color: #10b981;
        }
        .profit-positive {
            color: #10b981 !important;
            font-weight: bold !important;
        }
        .profit-negative {
            color: #ef4444 !important;
            font-weight: bold !important;
        }
        .profit-neutral {
            color: #d1d5db !important;
            font-weight: bold !important;
        }
        .session-digit-locked {
            background: linear-gradient(135deg, #1e3a8a, #1e40af) !important;
            border: 2px solid #3b82f6 !important;
            color: white !important;
        }
        .status-win {
            color: #10b981 !important;
            font-weight: bold !important;
            text-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
        }
        .status-loss {
            color: #ef4444 !important;
            font-weight: bold !important;
        }
        .status-trade {
            color: #f59e0b !important;
            font-weight: bold !important;
        }
        .calculator-highlight {
            background: linear-gradient(135deg, #7c3aed, #8b5cf6) !important;
            border: 1px solid #a78bfa !important;
            color: white !important;
        }
        .calculator-warning {
            background: linear-gradient(135deg, #dc2626, #ef4444) !important;
            border: 1px solid #f87171 !important;
            color: white !important;
        }
        .calculator-safe {
            background: linear-gradient(135deg, #059669, #10b981) !important;
            border: 1px solid #34d399 !important;
            color: white !important;
        }
        @keyframes calculator-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        .calculator-pulse {
            animation: calculator-pulse 0.5s ease-out;
        }
        .balance-green {
            color: #10b981 !important;
            font-weight: bold !important;
        }
        .network-recovery-badge {
            background: linear-gradient(90deg, #f59e0b, #d97706) !important;
            animation: pulse-once 0.8s infinite;
        }
        /* Digit Intelligence Engine Styles */
        .engine-status-warmup {
            background: linear-gradient(90deg, #f59e0b, #d97706) !important;
            animation: pulse-once 0.8s infinite;
        }
        .engine-status-analyzing {
            background: linear-gradient(90deg, #3b82f6, #1d4ed8) !important;
            animation: pulse-once 0.8s infinite;
        }
        .engine-status-ready {
            background: linear-gradient(90deg, #10b981, #059669) !important;
        }
        .engine-digit-score-high {
            color: #10b981 !important;
            font-weight: bold !important;
        }
        .engine-digit-score-medium {
            color: #f59e0b !important;
            font-weight: bold !important;
        }
        .engine-digit-score-low {
            color: #ef4444 !important;
            font-weight: bold !important;
        }
        .digit-analysis-panel {
            max-height: 300px;
            overflow-y: auto;
        }
        .digit-bar {
            height: 20px;
            border-radius: 4px;
            margin: 2px 0;
            transition: all 0.3s ease;
        }
        .digit-bar:hover {
            transform: scale(1.02);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght400;600;700&display=swap" rel="stylesheet">
</head>
<body class="min-h-screen p-4 sm:p-8 flex items-start justify-center">

    <div class="w-full max-w-6xl bg-gray-800 text-gray-100 shadow-2xl rounded-xl p-5 md:p-6">
        <div class="flex justify-between items-center mb-4">
            <h1 class="text-3xl font-extrabold text-green-400 border-b border-gray-700 pb-2">
                DigitMatchStar Bot 
                <span id="status-badge" class="ml-3 inline-flex items-center px-3 py-1 text-sm font-medium rounded-full connection-badge-disconnected text-white shadow-md">
                    ðŸ”´ DISCONNECTED
                </span>
                <span id="contract-type-badge" class="contract-type-badge bg-purple-600 text-white">DIGITMATCH</span>
                <button id="soundToggle" onclick="toggleSound()" class="sound-icon-btn" aria-label="Toggle sound" title="Sound ON">ðŸ”Š</button>

                <!-- Intelligence Engine Badge -->
                <span id="engine-status-badge" class="ml-2 inline-flex items-center px-3 py-1 text-sm font-medium rounded-full engine-status-warmup text-white shadow-md">
                    ðŸ”¥ ENGINE: WARM-UP
                </span>
                <!-- Network Recovery Badge -->
                <span id="network-recovery-badge" class="ml-2 inline-flex items-center px-3 py-1 text-sm font-medium rounded-full hidden network-recovery-badge text-white shadow-md">
                    ðŸ”„ AUTO-RECOVER
                </span>
                <!-- Account toggle -->
                <div class="account-toggle-container ml-3">
                    <span class="account-label account-label-demo">DEMO</span>
                    <label class="account-toggle">
                        <input type="checkbox" id="accTypeToggle" onchange="switchAccount()">
                        <span class="account-toggle-slider"></span>
                    </label>
                    <span class="account-label account-label-real">REAL</span>
                </div>
            </h1>
            <div class="controls-wrap flex flex-col sm:flex-row sm:items-center sm:justify-end gap-2 w-full sm:w-auto">
                <div class="flex flex-wrap sm:flex-nowrap items-center gap-2 w-full sm:w-auto sm:justify-end">
<div class="flex flex-wrap items-center gap-2 w-full sm:w-auto sm:justify-end">
                        <span id="networkRecoveryIndicator" class="status-chip on" title="Auto-Recovery is ON">
                            <span class="status-icon" aria-hidden="true">ðŸ”„</span>
                            <span class="status-dot" aria-hidden="true"></span>
                            <span class="status-label">Auto-Recovery</span>
                        </span>
                        <span id="engineIndicator" class="status-chip on" title="AI Engine is ON">
                            <span class="status-icon" aria-hidden="true">ðŸ§ </span>
                            <span class="status-dot" aria-hidden="true"></span>
                            <span class="status-label">AI Engine</span>
                        </span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
            <!-- LEFT COLUMN: MARKET STATUS & ENGINE ANALYSIS -->
            <div class="lg:col-span-1">
                <div class="bg-gray-900 border border-gray-700 rounded-xl p-4 shadow-lg">
                    <h2 class="text-lg font-bold text-cyan-400 mb-4 pb-2 border-b border-gray-700">
                        ðŸ“Š MARKET STATUS
                    </h2>
                    
                    <!-- Connection Status -->
                    <div class="mb-4 p-3 bg-gray-800 rounded-lg border border-gray-600">
                        <h3 class="text-sm font-bold text-gray-300 mb-2">Market Status</h3>
                        <div class="grid grid-cols-2 gap-2 text-xs">
                            <div>
                                <span class="text-gray-400">Connection:</span>
                                <span id="market_status" class="ml-2 font-bold text-red-400">Offline</span>
                            </div>
                            <div>
                                <span class="text-gray-400">Symbol:</span>
                                <span id="current_symbol" class="ml-2 font-bold text-cyan-400">V. 10 Index</span>
                            </div>
                            <div>
                                <span class="text-gray-400">Ticks Received:</span>
                                <span id="ticks_received" class="ml-2 font-bold text-green-400">0</span>
                            </div>
                            <div>
                                <span class="text-gray-400">Tick Rate:</span>
                                <span id="current_tick_rate" class="ml-2 font-bold text-blue-400">0/s</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Digit Intelligence Engine Panel -->
                    <div class="mb-4 p-3 bg-gray-800 rounded-lg border border-purple-500/50">
                        <h3 class="text-sm font-bold text-purple-400 mb-3 flex items-center">
                            ðŸ§  DIGIT INTELLIGENCE ENGINE
                            <span id="engine-warmup-progress" class="ml-auto text-xs bg-gray-700 px-2 py-1 rounded">
                                0%
                            </span>
                        </h3>
                        
                        <!-- Engine Status -->
                        <div class="mb-3 p-2 bg-gray-900 rounded border border-gray-700">
                            <div class="text-xs font-semibold text-gray-300 mb-1">Status:</div>
                            <div id="engine-status-text" class="text-sm font-bold text-yellow-400">Warming up...</div>
                            <div id="engine-regime-status" class="text-xs text-gray-400 mt-1">Regime: Unknown</div>
                        </div>
                        
                        <!-- Selected Digit -->
                        <div class="mb-3 p-2 bg-gray-900 rounded border border-green-500/30">
                            <div class="text-xs font-semibold text-green-400 mb-1">AI Recommended Digit:</div>
                            <div id="ai-recommended-digit" class="text-center text-green-400">-</div>
                            <div id="ai-digit-score" class="text-xs text-gray-400 text-center">Score: -</div>
                        </div>
                        
                        <!-- Digit Analysis (Collapsible) -->
                        <div class="mt-2">
                            <button onclick="toggleDigitAnalysis()" class="w-full text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded mb-2">
                                ðŸ“Š Show Digit Analysis <span id="digit-analysis-toggle">â–¼</span>
                            </button>
                            <div id="digit-analysis-panel" class="digit-analysis-panel hidden p-2 bg-gray-900 rounded border border-gray-700">
                                <div class="text-xs font-semibold text-gray-300 mb-2">Digit Statistics:</div>
                                <div id="digit-analysis-content" class="text-xs text-gray-400">
                                    Warming up engine...
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Session Status Display -->
                    <div id="session_display" class="mt-4 p-3 bg-gray-800 rounded border border-blue-500/30 hidden">
                        <h3 class="text-sm font-bold text-blue-300 mb-2">Active Session</h3>
                        <div class="flex items-center justify-between">
                            <div>
                                <div class="text-xs text-gray-300">Digit:</div>
                                <div id="session_digit" class="text-xl font-bold text-green-400">-</div>
                            </div>
                            <div>
                                <div class="text-xs text-gray-300">Trades:</div>
                                <div id="session_trades" class="text-sm font-bold text-yellow-400">0/10</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- MIDDLE COLUMN: MAIN CONTROLS -->
            <div class="lg:col-span-2">
                <!-- MARTINGALE CALCULATOR -->
                <div class="mb-6 p-4 bg-gray-900 rounded-xl border border-purple-500/50 shadow-lg">
                    <h2 class="text-lg font-bold text-purple-400 mb-3 pb-2 border-b border-gray-700 flex items-center">
                        ðŸ§® MARTINGALE CALCULATOR
                        <button onclick="toggleCalculator()" class="ml-auto text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded">
                            <span id="calcToggleIcon">âˆ’</span>
                        </button>
                    </h2>
                    
                    <div id="calculatorContent" class="transition-all duration-300">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                            <!-- Left Column: Inputs -->
                            <div class="space-y-3">
                                <div>
                                    <label class="block text-xs font-semibold text-gray-300 mb-1">Base Stake ($)</label>
                                    <input type="number" id="calc_base_stake" value="1.0" min="0.1" step="0.1" 
                                        class="w-full rounded-md bg-gray-700 border border-gray-600 text-white shadow-sm focus:border-purple-500 focus:ring-purple-500 py-1.5 px-2 text-sm calculator-highlight">
                                </div>
                                
                                <div>
                                    <label class="block text-xs font-semibold text-gray-300 mb-1">Multiplier</label>
                                    <input type="number" id="calc_multiplier" value="1.15" min="1.0" step="0.01" 
                                        class="w-full rounded-md bg-gray-700 border border-gray-600 text-white shadow-sm focus:border-purple-500 focus:ring-purple-500 py-1.5 px-2 text-sm">
                                </div>
                                
                                <div>
                                    <label class="block text-xs font-semibold text-gray-300 mb-1">Max Trades</label>
                                    <input type="number" id="calc_max_trades" value="10" min="1" max="100" 
                                        class="w-full rounded-md bg-gray-700 border border-gray-600 text-white shadow-sm focus:border-purple-500 focus:ring-purple-500 py-1.5 px-2 text-sm">
                                </div>
                                
                                <div>
                                    <label class="block text-xs font-semibold text-gray-300 mb-1">Bankroll Limit ($)</label>
                                    <input type="number" id="calc_bankroll_limit" value="50.0" min="1.0" step="0.1" 
                                        class="w-full rounded-md bg-gray-700 border border-gray-600 text-white shadow-sm focus:border-purple-500 focus:ring-purple-500 py-1.5 px-2 text-sm">
                                </div>
                                
                                <button onclick="calculateMartingale()" 
                                    class="w-full mt-2 px-4 py-2 bg-purple-600 text-white font-bold rounded-lg hover:bg-purple-700 transition">
                                    ðŸ§® CALCULATE
                                </button>
                            </div>
                            
                            <!-- Right Column: Results -->
                            <div class="space-y-3">
                                <div class="p-3 bg-gray-800 rounded-lg border border-green-500/50">
                                    <div class="text-xs font-semibold text-green-400 mb-1">Total Required</div>
                                    <div id="calc_total_required" class="text-xl font-bold text-white">$0.00</div>
                                    <div class="text-xs text-gray-400 mt-1">For all trades</div>
                                </div>
                                
                                <div class="p-3 bg-gray-800 rounded-lg border border-blue-500/50">
                                    <div class="text-xs font-semibold text-blue-400 mb-1">Final Stake</div>
                                    <div id="calc_final_stake" class="text-lg font-bold text-white">$0.00</div>
                                    <div class="text-xs text-gray-400 mt-1">Last trade amount</div>
                                </div>
                                
                                <div class="p-3 bg-gray-800 rounded-lg border border-yellow-500/50">
                                    <div class="text-xs font-semibold text-yellow-400 mb-1">Bankroll Status</div>
                                    <div id="calc_bankroll_status" class="text-lg font-bold text-white">-</div>
                                    <div class="text-xs text-gray-400 mt-1">vs. your limit</div>
                                </div>
                                
                                <div class="p-3 bg-gray-800 rounded-lg border border-cyan-500/50">
                                    <div class="text-xs font-semibold text-cyan-400 mb-1">Profit on Win</div>
                                    <div id="calc_profit_on_win" class="text-lg font-bold text-white">$0.00</div>
                                    <div class="text-xs text-gray-400 mt-1">9x payout minus investment</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Stake Progression Table -->
                        <div class="mt-4">
                            <div class="text-xs font-semibold text-gray-300 mb-2">Stake Progression</div>
                            <div id="calc_progression" class="text-xs text-gray-400 italic">Click CALCULATE to see stake progression</div>
                        </div>
                    </div>
                </div>
                
                <!-- Main Trading Controls -->
                <div class="grid grid-cols-2 lg:grid-cols-3 gap-3 mb-6">
                    <!-- Symbol -->
                    <div>
                        <label for="symbol" class="block text-xs font-semibold text-gray-300 mb-1">Symbol</label>
                        <select id="symbol" class="block w-full rounded-md bg-gray-700 border border-gray-600 text-white shadow-sm focus:border-green-500 focus:ring-green-500 py-1.5 px-2 text-sm">
                            <option value="R_10">V. 10 Index</option>
                            <option value="R_100">V. 100 Index</option>
                            <option value="R_25">V. 25 Index</option>
                            <option value="R_50">V. 50 Index</option>
                            <option value="R_75">V. 75 Index</option>
                        </select>
                    </div>
                    
                    <!-- Predicted Digit -->
                    <div>
                        <label for="predictedDigit" class="block text-xs font-semibold text-gray-300 mb-1">
                            Current Digit
                        </label>
                        <div class="flex space-x-2">
                            <input type="number" id="predictedDigit" value="5" min="0" max="9" 
                                class="block w-full rounded-md bg-gray-700 border border-gray-600 text-white shadow-sm focus:border-green-500 focus:ring-green-500 py-1.5 px-2 text-sm text-center">
                            <button onclick="useAIRecommendedDigit()" 
                                class="px-2 py-1 bg-purple-600 text-white text-xs font-bold rounded hover:bg-purple-700 transition"
                                title="Use AI Recommended Digit">
                                ðŸ¤– AI
                            </button>
                        </div>
                    </div>

                    <!-- Contract Type -->
                    <div>
                        <label for="contractType" class="block text-xs font-semibold text-gray-300 mb-1">Contract Type</label>
                        <select id="contractType" class="block w-full rounded-md bg-gray-700 border border-gray-600 text-white shadow-sm focus:border-green-500 focus:ring-green-500 py-1.5 px-2 text-sm">
                            <option value="DIGITMATCH">DIGITMATCH</option>
                        </select>
                    </div>

                    <!-- Base Stake -->
                    <div>
                        <label for="baseStake" class="block text-xs font-semibold text-gray-300 mb-1">Base Stake</label>
                        <input type="number" id="baseStake" value="1.0" min="0.1" step="0.1" 
                            class="block w-full rounded-md bg-gray-700 border border-gray-600 text-white shadow-sm focus:border-green-500 focus:ring-green-500 py-1.5 px-2 text-sm">
                    </div>

                    <!-- Multiplier -->
                    <div>
                        <label for="multiplier" class="block text-xs font-semibold text-gray-300 mb-1">Multiplier</label>
                        <input type="number" id="multiplier" value="1.15" min="1.0" step="0.01" 
                            class="block w-full rounded-md bg-gray-700 border border-gray-600 text-white shadow-sm focus:border-green-500 focus:ring-green-500 py-1.5 px-2 text-sm">
                    </div>

                    
                    <!-- S20 Threshold (%) -->
                    <div>
                        <label for="s20Threshold" class="block text-xs font-semibold text-gray-300 mb-1">S20 Threshold (%)</label>
                        <input type="number" id="s20Threshold" value="5" min="0" max="100" step="0.1"
                            class="block w-full rounded-md bg-gray-700 border border-gray-600 text-white shadow-sm focus:border-green-500 focus:ring-green-500 py-1.5 px-2 text-sm">
                    </div>

<!-- Max Trades -->
                    <div>
                        <label for="maxTrades" class="block text-xs font-semibold text-gray-300 mb-1">Max Trades</label>
                        <input type="number" id="maxTrades" value="10" min="1" max="100" 
                            class="block w-full rounded-md bg-gray-700 border border-gray-600 text-white shadow-sm focus:border-green-500 focus:ring-green-500 py-1.5 px-2 text-sm">
                    </div>

                    <!-- Max Cycle Trades (Progression Cap) -->
                    <div>
                        <label for="maxCycleTrades" class="block text-xs font-semibold text-gray-300 mb-1">Max Cycle Trades</label>
                        <input type="number" id="maxCycleTrades" value="10" min="1" max="50"
                            class="block w-full rounded-md bg-gray-700 border border-gray-600 text-white shadow-sm focus:border-green-500 focus:ring-green-500 py-1.5 px-2 text-sm">
                    </div>
                    
                    <!-- Mode Toggle - ONLY INSTANT AND AI AUTO -->
                    <div class="col-span-2 lg:col-span-3">
                        <label class="block text-xs font-semibold text-gray-300 mb-1">Execution Mode</label>
                        <div class="grid grid-cols-2 gap-2">
                            <button id="mode_instant" onclick="switchMode('instant')" 
                                class="px-4 py-2 bg-green-600 text-white font-bold rounded-lg hover:bg-green-700 transition">
                                âš¡ INSTANT
                            </button>
                            <button id="mode_ai" onclick="switchMode('ai')" 
                                class="px-4 py-2 bg-purple-600 text-white font-bold rounded-lg hover:bg-purple-700 transition">
                                ðŸ¤– AI AUTO
                            </button>
                        </div>
                        <p id="mode_description" class="text-xs text-gray-400 mt-1">
                            âš¡ INSTANT: Trade on each tick with manual digit
                        </p>
                    </div>
                </div>
                
                <!-- METRICS -->
                <div class="grid grid-cols-3 gap-3">
                    <div class="bg-gray-700 rounded-lg p-2 shadow-inner border border-green-500/50 col-span-2">
                        <p class="text-[10px] font-semibold text-green-500 uppercase">Current Tick</p>
                        <p id="metricLiveTick" class="text-xl font-extrabold text-white">---</p>
                        <p id="metricLastDigit" class="text-lg font-bold text-green-300">Digit: ?</p>
                        <p id="metricTickRate" class="text-xs font-bold text-blue-400">Ticks/sec: --</p>
                    </div>
                    
                    <div class="bg-gray-700 rounded-lg p-2 shadow-inner border border-green-500/50">
                        <p class="text-[10px] font-semibold text-green-500 uppercase">Balance</p>
                        <p id="metricAccountBalance" class="text-lg font-bold balance-green">$---</p>
                    </div>
                    
                    <div class="bg-gray-700 rounded-lg p-2 shadow-inner">
                        <p class="text-[10px] font-semibold text-green-500 uppercase">Trade #</p>
                        <p id="metricTradeCount" class="text-lg font-bold text-white">0</p>
                    </div>
                    
                    <div class="bg-gray-700 rounded-lg p-2 shadow-inner">
                        <p class="text-[10px] font-semibold text-lime-400 uppercase">P/L</p>
                        <p id="metricTotalProfit" class="text-lg font-bold profit-neutral">$0.00</p>
                    </div>
                    
                    <div class="bg-gray-700 rounded-lg p-2 shadow-inner">
                        <p class="text-[10px] font-semibold text-green-500 uppercase">Stake</p>
                        <p id="metricCurrentStake" class="text-lg font-bold text-white">$0.00</p>
                    </div>
                    
                    <!-- TRADE STATUS SECTION -->
                    <div id="trade-result-container" class="bg-gray-900 rounded-lg p-3 shadow-inner border border-yellow-500/50 col-span-3">
                        <div class="flex justify-between items-center mb-2">
                            <p class="text-[10px] font-semibold text-yellow-500 uppercase">TRADE STATUS</p>
                            <p id="metricTradeResult" class="text-xs font-bold text-gray-400">READY</p>
                        </div>
                        <div class="mb-2">
                            <p class="text-[10px] font-semibold text-gray-400 uppercase mb-1">Status:</p>
                            <p id="metricPreviousResult" class="text-sm font-bold text-gray-300">Waiting for connection...</p>
                        </div>
                        <div>
                            <p class="text-[10px] font-semibold text-gray-400 uppercase mb-1">Action:</p>
                            <p id="metricNextAction" class="text-sm font-bold text-yellow-400">Start bot to begin</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- START/STOP BUTTON -->
        <div class="flex justify-center mb-5">
            <button id="toggleButton" onclick="toggleBot()" 
                class="w-full md:w-1/2 px-6 py-3 bg-green-600 text-white font-bold text-lg rounded-lg shadow-xl hover:bg-green-700 transition duration-150">
                ðŸš€ START BOT
            </button>
        </div>

        <!-- LOG AREA -->
        <div id="log-column" class="w-full flex flex-col">
            <h2 class="text-lg font-bold text-gray-300 mb-2 border-b border-gray-700 pb-1">Live Log</h2>
            <div id="log-area" class="flex-grow h-80 bg-gray-900 text-lime-400 p-2.5 rounded-lg overflow-y-scroll text-xs whitespace-pre-wrap shadow-inner">
[00:00:00] ðŸ¤– Deriv Bot Initialized
[00:00:00] ðŸ“Š Ready to connect to live market
[00:00:00] ðŸ§® Martingale calculator ready
[00:00:00] ðŸ”„ Auto-recovery system ready
[00:00:00] ðŸ§  Digit Intelligence Engine loaded
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // DERIV DIGIT MATCH INTELLIGENCE ENGINE - FIXED FOR DIGIT 0
        // Warm-up (1000 ticks) â†’ Live incremental â†’ Regime + Smart digit selection
        // ============================================================================
        
        // Global AI thresholds (single source of truth)
        window.AI_THRESHOLDS = {
            minSupport: 22,

            // EARLY PRESSURE (REALISTIC MODE)
            minH5: 0.42,        // ðŸ”¥ KEY CHANGE (from 0.50 â†’ 0.45)
            minP10: 0.66,       // slightly relaxed

            maxPersistenceStable: 97,      // allow more clean cold
            maxPersistenceStableRelax: 97,
            maxPersistenceUnstable: 93,    // still strict when unstable

            maxExtend: 3,
            require_g_lt_p90: true
        ,
            // PRESSURE ZONE: only recommend digits whose current gap is close to P90
            // Example: min=0.75 means "within last 15% of the P90 gap"
            pressureZoneEnabled: true,
            // Looser default so you still get trades, but quality stays high.
            // 0.75 means "within last 25% of P90"
            pressureZoneMinP90Ratio: 0.70,
            pressureZoneMaxP90Ratio: 0.95,
                        // Hard floor: never recommend if gap is far from P90 (prevents "gap 4, p90 20" type picks)
            pressureZoneMinFloorP90Ratio: 0.60,
// Adaptive fallback: if no digit qualifies at the first tier, the engine progressively relaxes.
            // It will NEVER go below pressureZoneMinFloorP90Ratio.
            pressureZoneFallbackMinP90Ratios: [0.70, 0.66, 0.63, 0.60]
        };


        // ============================================================================
        // SURVIVAL CURVE ENGINE CONFIG (Empirical conditional survival from historical gaps)
        // ============================================================================
        window.SURVIVAL_WINDOW = 2000;   // rolling digits window (oldest -> newest)
        window.lastDigits = [];          // rolling buffer of last digits for SurvivalEngine

        // Ranking defaults (tweakable)
        window.SURVIVAL_CFG = {
            minPm5: 0.60,
            maxS20: 0.05,
            maxETM: 12,
            requirePressure: true
        };

        // Engine State
        window.digitIntelligenceEngine = {
            enabled: true,
            warmupDone: false,
            warmupTicks: 0,
            targetWarmupTicks: 1000,
            tickIndex: 0,
            
            // Data structures
            digitStats: Array(10).fill().map(() => ({
                gaps: [],
                lastSeen: null,
                currentGap: 0,

                avgGap: 0,
                p75Gap: 0,
                p90Gap: 0,
                maxGap: 0,

                coldHistory: [],
                longestColdStreak: 0,
                avgColdDuration: 0,

                persistenceScore: 0,
                consecutiveExtendingGaps: 0,
                lastGap: null,

                isUnstable: false,
                count: 0
            })),
            
            // Regime detector
            regime: {
                window: 200,
                digits: [],
                counts: Array(10).fill(0)
            },
            
            // Current recommendation
            currentRecommendation: null,
            currentRecommendations: null,
            
            // Initialize engine
            init: function() {
                this.reset();
                log('ðŸ§  Digit Intelligence Engine initialized', 'ENGINE');
            },
            
            // Reset engine
            reset: function() {
                this.warmupDone = false;
                this.warmupTicks = 0;
                this.tickIndex = 0;
                this.currentRecommendation = null;
                this.currentRecommendations = null;
                
                this.digitStats = Array(10).fill().map(() => ({
                    gaps: [],
                    lastSeen: null,
                    currentGap: 0,
                    avgGap: 0,
                    p75Gap: 0,
                    p90Gap: 0,
                    maxGap: 0,
                    coldHistory: [],
                    longestColdStreak: 0,
                    avgColdDuration: 0,
                    persistenceScore: 0,
                    consecutiveExtendingGaps: 0,
                    lastGap: null,
                    isUnstable: false,
                    count: 0
                }));
                
                this.regime = {
                    window: 200,
                    digits: [],
                    counts: Array(10).fill(0)
                };
                
                updateEngineStatus('Warming up...', 'WARMUP', 0);
                log('ðŸ§  Engine reset - ready for warm-up', 'ENGINE');
            },
            
            // Process warm-up ticks
            processWarmupTicks: function(prices) {
                if (!this.enabled) return;
                
                
                initTickFormatFromPrices(prices);
                for (let i = 0; i < prices.length; i++) {
                    // Digit extraction using auto-detected decimals (preserves trailing zeros)
                    updateTickFormatFromQuote(prices[i]);
                    const digit = getLastDigitFromQuote(prices[i]);
                    if (isNaN(digit) || digit < 0 || digit > 9) continue;

                    // SurvivalEngine rolling digits buffer
                    window.lastDigits.push(digit);
                    if (window.lastDigits.length > (window.SURVIVAL_WINDOW || 2000)) window.lastDigits.shift();
                    
                    // Debug digit 0
                    if (digit === 0) {
                        console.log('Warm-up: Digit 0 detected from price:', prices[i]);
                    }
                    
                    this.updateRegime(digit);
                    this.onNewDigit(digit);
                    
                    this.warmupTicks++;
                    this.tickIndex++;
                    
                    // Update progress every 10 ticks
                    if (this.warmupTicks % 10 === 0) {
                        const progress = Math.min(100, Math.round((this.warmupTicks / this.targetWarmupTicks) * 100));
                        updateEngineStatus(`Warming up... ${this.warmupTicks}/${this.targetWarmupTicks}`, 'WARMUP', progress);
                    }
                }
                
                if (this.warmupTicks >= this.targetWarmupTicks && !this.warmupDone) {
                    this.warmupDone = true;
                    log(`ðŸ§  Warm-up complete! Analyzed ${this.warmupTicks} ticks`, 'ENGINE');
                    updateEngineStatus('Analyzing market...', 'ANALYZING', 100);
                    
                    // Initial analysis
                    setTimeout(() => {
                        this.analyzeAndRecommend();
                    }, 100);
                }
            },
            
            // Process live tick
            processLiveTick: function(digit) {
                if (!this.enabled) return;
                
                // ðŸ”¥ FIXED: digit 0 is valid, so check for NaN instead
                if (isNaN(digit) || digit < 0 || digit > 9) return;

                // SurvivalEngine rolling digits buffer
                window.lastDigits.push(digit);
                if (window.lastDigits.length > (window.SURVIVAL_WINDOW || 2000)) window.lastDigits.shift();
                
                // ðŸ”¥ FIX #3: advance tick index
                this.tickIndex++;
                
                // Update warmup ticks if still in warmup phase
                if (!this.warmupDone) {
                    this.warmupTicks++;
                    
                    // Update progress every 10 ticks
                    if (this.warmupTicks % 10 === 0) {
                        const progress = Math.min(100, Math.round((this.warmupTicks / this.targetWarmupTicks) * 100));
                        updateEngineStatus(`Warming up... ${this.warmupTicks}/${this.targetWarmupTicks}`, 'WARMUP', progress);
                    }
                    
                    if (this.warmupTicks >= this.targetWarmupTicks && !this.warmupDone) {
                        this.warmupDone = true;
                        log(`ðŸ§  Warm-up complete! Analyzed ${this.warmupTicks} ticks`, 'ENGINE');
                        updateEngineStatus('Analyzing market...', 'ANALYZING', 100);
                    }
                }
                
                this.updateRegime(digit);
                this.onNewDigit(digit);
                
                // Update analysis every 50 ticks
                if (this.tickIndex % 50 === 0) {
                    this.analyzeAndRecommend();
                }
            },
            
            // Update regime statistics
            updateRegime: function(digit) {
                this.regime.digits.push(digit);
                this.regime.counts[digit]++;
                
                if (this.regime.digits.length > this.regime.window) {
                    const old = this.regime.digits.shift();
                    this.regime.counts[old]--;
                }
            },
            
            // Compute regime status
            computeRegimeStatus: function() {
                const n = this.regime.digits.length;
                if (n < 60) return { ok: false, label: "WARMING" };
                
                let H = 0;
                for (let d = 0; d < 10; d++) {
                    const p = this.regime.counts[d] / n;
                    if (p > 0) H -= p * Math.log(p);
                }
                const entropy = H / Math.log(10);
                
                const expected = n / 10;
                let chi2 = 0;
                for (let d = 0; d < 10; d++) {
                    const diff = this.regime.counts[d] - expected;
                    chi2 += (diff * diff) / expected;
                }
                
                const dominance = Math.max(...this.regime.counts) / n;
                
                const ok =
                    entropy >= 0.88 &&
                    chi2 <= 28 &&
                    dominance <= 0.20;
                
                return { 
                    ok, 
                    entropy: entropy.toFixed(3), 
                    chi2: chi2.toFixed(2), 
                    dominance: dominance.toFixed(3),
                    label: ok ? "STABLE" : "UNSTABLE"
                };
            },
            
            // Handle new digit - FIXED FOR DIGIT 0
            onNewDigit: function(digit) {
                // ðŸ”¥ FIXED: digit can be 0, so check for NaN instead
                if (isNaN(digit) || digit < 0 || digit > 9) {
                    console.log('Invalid digit skipped:', digit);
                    return;
                }

                const s = this.digitStats[digit];

                // ðŸ”¥ FIX: Always increment count for valid digits
                s.count++;

                // gap update
                if (s.lastSeen !== null) {
                    const gap = this.tickIndex - s.lastSeen - 1;
                    if (gap >= 0) this.updateGapStats(digit, gap);
                }

                s.lastSeen = this.tickIndex;

                // update current gaps
                for (let d = 0; d < 10; d++) {
                    const st = this.digitStats[d];
                    st.currentGap = (st.lastSeen === null)
                        ? this.tickIndex
                        : (this.tickIndex - st.lastSeen);
                }
            },
            
            // Update gap statistics
            updateGapStats: function(digit, gap) {
                const s = this.digitStats[digit];
                
                s.gaps.push(gap);
                if (s.gaps.length > 300) s.gaps.shift();
                
                if (s.lastGap !== null) {
                    if (gap > s.lastGap) s.consecutiveExtendingGaps++;
                    else s.consecutiveExtendingGaps = 0;
                }
                s.lastGap = gap;
                
                if (s.gaps.length > 0) {
                    const sorted = [...s.gaps].sort((a,b)=>a-b);
                    s.avgGap = s.gaps.reduce((a,b)=>a+b,0) / s.gaps.length;
                    s.p75Gap = sorted[Math.floor(0.75 * sorted.length)];
                    s.p90Gap = sorted[Math.floor(0.90 * sorted.length)];
                    s.maxGap = sorted[sorted.length - 1];
                    
                    if (gap > s.avgGap) {
                        s.coldHistory.push(gap);
                        if (s.coldHistory.length > 200) s.coldHistory.shift();
                    }
                    
                    s.longestColdStreak = s.coldHistory.length ? Math.max(...s.coldHistory) : 0;
                    s.avgColdDuration = s.coldHistory.length
                        ? s.coldHistory.reduce((a,b)=>a+b,0) / s.coldHistory.length
                        : 0;
                    
                    s.isUnstable = (s.p90Gap > s.avgGap * 3 + 1);
                    
                    this.computePersistenceScore(digit);
                }
            },
            
            // Compute persistence score
            computePersistenceScore: function(digit) {
                const s = this.digitStats[digit];
                
                if (s.gaps.length < 20) {
                    s.persistenceScore = 40;
                    return;
                }
                
                const tailRatio = s.longestColdStreak / Math.max(s.avgColdDuration, 1);
                const p90Ratio  = s.p90Gap / Math.max(s.avgGap * 3, 1);
                
                let score =
                    40 * Math.min(tailRatio / 2, 1) +
                    60 * Math.min(p90Ratio, 1);
                
                s.persistenceScore = Math.min(Math.round(score), 100);
            },
            
            // Conditional return probability
            conditionalReturnProb: function(digit, g, K = 10) {
                const gaps = this.digitStats[digit].gaps;
                if (gaps.length < 30) return 0.5;
                
                let denom = 0;
                let numer = 0;
                
                for (const L of gaps) {
                    if (L > g) {
                        denom++;
                        if (L <= g + K) numer++;
                    }
                }
                
                if (denom === 0) return 0.0;
                return numer / denom;
            },
            
            // Select best digit using AI logic
            
selectBestDigit: function() {
                if (!this.warmupDone || !this.enabled) return null;

                const regimeStatus = this.computeRegimeStatus();
                if (!regimeStatus.ok) {
                    log(`ðŸ§  Regime unstable: E=${regimeStatus.entropy}, Ï‡Â²=${regimeStatus.chi2}, D=${regimeStatus.dominance}`, 'ENGINE');
                    return null;
                }

                const thresholds = window.AI_THRESHOLDS;

                const maxPersistence =
                    regimeStatus.label === "STABLE"
                        ? thresholds.maxPersistenceStable
                        : thresholds.maxPersistenceUnstable;

                const rawPressureTiers = (thresholds.pressureZoneEnabled &&
                    Array.isArray(thresholds.pressureZoneFallbackMinP90Ratios) &&
                    thresholds.pressureZoneFallbackMinP90Ratios.length)
                    ? thresholds.pressureZoneFallbackMinP90Ratios
                    : [thresholds.pressureZoneEnabled ? thresholds.pressureZoneMinP90Ratio : 0.0];

                const pressureFloor = (thresholds.pressureZoneEnabled && typeof thresholds.pressureZoneMinFloorP90Ratio === "number")
                    ? thresholds.pressureZoneMinFloorP90Ratio
                    : 0.0;

                // Ensure tiers are sorted highâ†’low, unique, and never drop below the floor.
                const pressureTiers = Array.from(new Set(rawPressureTiers))
                    .map(v => (typeof v === "number" ? v : 0.0))
                    .filter(v => v >= pressureFloor && v < 1)
                    .sort((a, b) => b - a);

                if (thresholds.pressureZoneEnabled && pressureTiers.length === 0) {
                    pressureTiers.push(Math.max(0, Math.min(0.999, pressureFloor)));
                }

                const runPass = (activeMinP90Ratio) => {
                    let candidates = [];

                    for (let d = 0; d < 10; d++) {
                        const s = this.digitStats[d];
                        const g = s.currentGap;
                        const p90 = Math.max(s.p90Gap, 1);
                        const p90Ratio = g / p90;
                        const extendRatio = g / s.avgGap;

                        // ðŸ”¥ HARD TAIL BLOCK: extreme stretch vs history
                        if (extendRatio > 2.8) continue;

                        // ðŸ”¥ Biased regime + stretched digit = tail risk
                        if (regimeStatus.entropy < 0.96 && extendRatio > 1.5) continue;

                        // ðŸ”¥ Tail forming: suppressed digit + stretched gap
                        if (s.persistenceScore > 90 && extendRatio > 1.8) continue;

                        const P5  = this.conditionalReturnProb(d, g, 5);
                        const P10 = this.conditionalReturnProb(d, g, 10);

                        // Filter conditions
                        if (s.gaps.length < thresholds.minSupport) continue;

                        // STRONG EARLY FIRST (H5 primary gate)
                        if (P5 < thresholds.minH5) continue;

                        // MEDIUM EARLY SECOND
                        if (P10 < thresholds.minP10) continue;

                        // SAFETY
                        if (thresholds.require_g_lt_p90 && g >= p90) continue;

                        // PRESSURE ZONE (adaptive): prefer digits close to P90, but relax if too strict.
                        if (thresholds.pressureZoneEnabled) {
                            if (p90Ratio < activeMinP90Ratio) continue;
                            if (p90Ratio >= thresholds.pressureZoneMaxP90Ratio) continue;
                        }

                        // Cold-stickiness / persistence filters
                        const effectiveMaxPersistence = (
                            regimeStatus.label === "STABLE" &&
                            P10 >= (thresholds.minP10 + 0.05) &&
                            extendRatio <= 1.3
                        ) ? thresholds.maxPersistenceStableRelax : maxPersistence;

                        if (s.persistenceScore > effectiveMaxPersistence) continue;
                        if (s.consecutiveExtendingGaps > thresholds.maxExtend) continue;
                        if (s.isUnstable) continue;

                        // Calculate score (still strongly favors closest-to-P90)
                        const denom = Math.max(1 - activeMinP90Ratio, 1e-6);
                        const pressureScore = thresholds.pressureZoneEnabled
                            ? Math.max(0, Math.min(1, (p90Ratio - activeMinP90Ratio) / denom))
                            : Math.max(0, Math.min(1, g / p90));

                        const score =
                            0.45 * P10 +
                            0.25 * P5 +
                            0.20 * pressureScore +
                            0.10 * (1 - s.persistenceScore / 100);

                        candidates.push({
                            digit: d,
                            score: score,
                            P10: P10,
                            P5: P5,
                            gap: g,
                            persistenceScore: s.persistenceScore,
                            isUnstable: s.isUnstable,
                            pressureMinP90Ratio: activeMinP90Ratio
                        });
                    }

                    candidates.sort((a, b) => b.score - a.score);

// Ensure we always return TWO DISTINCT digits (no duplicates).
const unique = [];
const seen = new Set();
for (const c of candidates) {
    if (seen.has(c.digit)) continue;
    seen.add(c.digit);
    unique.push(c);
    if (unique.length >= 2) break;
}
return unique.length === 2 ? unique : null;
};

                for (const activeMinP90Ratio of pressureTiers) {
                    const top2 = runPass(activeMinP90Ratio);
                    if (top2 && top2.length) return top2;
                }

                return null;
            },

            // Analyze and recommend digit
            analyzeAndRecommend: function() {
                const regimeStatus = this.computeRegimeStatus();

                if (!regimeStatus.ok) {
                    // Keep UI consistent when regime is unstable
                    this.currentRecommendation = null;
                    this.currentRecommendations = null;
                    document.getElementById('ai-recommended-digit').textContent = '-';
                    document.getElementById('ai-digit-score').textContent = 'Score: 0.0% | P10: 0.0% | NO-TRADE';
                    return;
                }

                const top2 = this.selectBestDigit();

                let best = (top2 && top2.length) ? top2[0] : null;
                let second = (top2 && top2.length > 1) ? top2[1] : null;

                // -----------------------------
                // Survival-curve overlay (always-on hybrid when data exists)
                // -----------------------------
                const minDigits = (typeof window.SURVIVAL_MIN_DIGITS === 'number') ? window.SURVIVAL_MIN_DIGITS : 80;
                const windowSize = window.SURVIVAL_WINDOW || 2000;

                let survivalStats = null;
                let survivalByDigit = null;
                let survivalTop3 = [];
                let survivalTop = null;

                try {
                    if (window.SurvivalEngine && Array.isArray(window.lastDigits) && window.lastDigits.length >= minDigits) {
                        survivalStats = window.SurvivalEngine.analyze(window.lastDigits, { window: windowSize });
                        survivalByDigit = new Map(survivalStats.map(s => [s.digit, s]));

                        // Try strict rank first (user cfg). If empty, fall back to global ranking (no "ignore" case).
                        let ranked = [];
                        try {
                            ranked = window.SurvivalEngine.rank(survivalStats, window.SURVIVAL_CFG || {});
                        } catch (_) {
                            ranked = [];
                        }

                        const scoreRaw = (x) =>
                            (2.0 * (x.pm5 || 0)) +
                            (1.0 * (x.pm10 || 0)) -
                            (2.5 * (x.s20 || 0)) -
                            (0.05 * Math.min(Number.isFinite(x.etm) ? x.etm : 100, 100));

                        const asScored = (arr) => arr.map(x => {
                            const raw = Number.isFinite(x.survivalScore) ? x.survivalScore : scoreRaw(x);
                            const norm = 1 / (1 + Math.exp(-raw));
                            return { ...x, survivalScore: raw, survivalNorm: norm };
                        });

                        let globalRanked = asScored(ranked);
                        if (!globalRanked.length) {
                            globalRanked = asScored(survivalStats).sort((a, b) => (b.survivalNorm - a.survivalNorm));
                        }

                        survivalTop3 = globalRanked.slice(0, 3);
                        survivalTop = survivalTop3[0] || null;
                    }
                } catch (e) {
                    console.warn('SurvivalEngine error:', e);
                    survivalStats = null;
                    survivalByDigit = null;
                    survivalTop3 = [];
                    survivalTop = null;
                }

                const hasSurvival = !!(survivalByDigit && survivalByDigit.size);

                // Expose latest survival stats for trading gates
                try {
                    window.latestSurvivalStats = Array.isArray(survivalStats) ? survivalStats : null;
                    window.latestSurvivalByDigit = Array.isArray(survivalStats)
                        ? Object.fromEntries(survivalStats.map(s => [s.digit, s]))
                        : null;
                    window.latestSurvivalUpdatedAt = Date.now();
                } catch (_) {
                    window.latestSurvivalStats = null;
                    window.latestSurvivalByDigit = null;
                }

                const attachHybrid = (candidate) => {
                    if (!candidate || !hasSurvival) return candidate;

                    const s = survivalByDigit.get(candidate.digit) || null;
                    if (s) {
                        const raw =
                            Number.isFinite(s.survivalScore) ? s.survivalScore :
                            (2.0 * (s.pm5 || 0)) + (1.0 * (s.pm10 || 0)) - (2.5 * (s.s20 || 0)) - (0.05 * Math.min(Number.isFinite(s.etm) ? s.etm : 100, 100));
                        const survNorm = 1 / (1 + Math.exp(-raw));

                        const base = Number.isFinite(candidate.score) ? candidate.score : 0.0;
                        const historyFactor = Math.min(1, (window.lastDigits.length / windowSize));
                        const wBase = (typeof window.SURVIVAL_BLEND === 'number') ? window.SURVIVAL_BLEND : 0.35;
                        const w = Math.max(0.10, Math.min(0.55, wBase * historyFactor));

                        candidate.survival = { ...s, survivalScore: raw, survivalNorm: survNorm };
                        candidate.source = 'HYBRID';
                        candidate.score = Math.max(0, Math.min(1, ((1 - w) * base) + (w * survNorm)));
                    } else {
                        candidate.source = 'HYBRID';
                        candidate.survival = null;
                    }
                    return candidate;
                };

                // If base engine has no pick, use survival's best digit (still HYBRID)
                if (!best && hasSurvival && survivalTop) {
                    best = {
                        digit: survivalTop.digit,
                        score: survivalTop.survivalNorm ?? (1 / (1 + Math.exp(-(survivalTop.survivalScore || 0)))),
                        P10: survivalTop.pm10 ?? 0,
                        P5: survivalTop.pm5 ?? 0,
                        gap: survivalTop.gap ?? 0,
                        persistenceScore: (this.digitStats[survivalTop.digit]?.persistenceScore ?? 0),
                        isUnstable: (this.digitStats[survivalTop.digit]?.isUnstable ?? false),
                        source: 'HYBRID',
                        survival: survivalTop
                    };
                } else {
                    best = attachHybrid(best);
                }

                // Optional override: if survival strongly prefers another digit, allow it to replace weak base picks.
                if (best && hasSurvival && survivalTop && survivalTop.digit !== best.digit) {
                    const baseScore = Number.isFinite(best.score) ? best.score : 0;
                    const survTopNorm = survivalTop.survivalNorm ?? (1 / (1 + Math.exp(-(survivalTop.survivalScore || 0))));
                    if (survTopNorm >= Math.max(0.62, baseScore + 0.08)) {
                        best = {
                            digit: survivalTop.digit,
                            score: survTopNorm,
                            P10: survivalTop.pm10 ?? 0,
                            P5: survivalTop.pm5 ?? 0,
                            gap: survivalTop.gap ?? 0,
                            persistenceScore: (this.digitStats[survivalTop.digit]?.persistenceScore ?? 0),
                            isUnstable: (this.digitStats[survivalTop.digit]?.isUnstable ?? false),
                            source: 'HYBRID',
                            survival: survivalTop
                        };
                    } else {
                        // Ensure survival metrics are attached even if not overriding.
                        best.survival = best.survival || survivalByDigit.get(best.digit) || null;
                        best.source = 'HYBRID';
                    }
                }

                if (best) {
                    // Build a blended pool so Digit B can still appear even when "best" was overridden by survival/hybrid.
                    const pool = [];

                    const pushCand = (c) => {
                        if (!c || !Number.isInteger(c.digit)) return;
                        pool.push(c);
                    };

                    if (top2 && top2.length) top2.forEach(pushCand);

                    if (hasSurvival && Array.isArray(survivalTop3) && survivalTop3.length) {
                        for (const s of survivalTop3) {
                            pushCand({
                                digit: s.digit,
                                score: (typeof s.survivalNorm === 'number') ? s.survivalNorm : 0,
                                source: 'SURVIVAL',
                                survival: s
                            });
                        }
                    }

                    // Ensure current "best" is included in the pool.
                    pushCand(best);

                    const blended = pool.map(attachHybrid).filter(Boolean);
                    blended.sort((a, b) => (b.score ?? 0) - (a.score ?? 0));

                    const picked = [];
                    const seen = new Set();
                    for (const c of blended) {
                        if (seen.has(c.digit)) continue;
                        seen.add(c.digit);
                        picked.push(c);
                        if (picked.length >= 2) break;
                    }

                    best = picked[0] || best;
                    second = picked.length > 1 ? picked[1] : null;

                    this.currentRecommendation = best;
                    this.currentRecommendations = (best && second) ? [best, second] : null;

                    // Update UI
                    const secondDigit = second ? second.digit : '-';
                    document.getElementById('ai-recommended-digit').innerHTML = `<div class="text-lg font-bold text-center text-green-400">Digit A: ${best.digit}</div><div class="text-lg font-bold text-center text-green-400">Digit B: ${secondDigit}</div>`;

                    const sourceLabel = best.source ? ` | ${best.source}` : '';

                    let survivalLabel = '';
                    if (hasSurvival) {
                        const s = best.survival || (survivalByDigit ? survivalByDigit.get(best.digit) : null);
                        if (s) {
                            survivalLabel =
                                ` | pm5:${Math.round((s.pm5 || 0) * 100)}% pm10:${Math.round((s.pm10 || 0) * 100)}% s20:${Math.round((s.s20 || 0) * 100)}% etm:${Number.isFinite(s.etm) ? s.etm.toFixed(1) : 'âˆž'}`;
                        } else {
                            survivalLabel = ` | Survival: N/A`;
                        }
                    } else {
                        const n = Array.isArray(window.lastDigits) ? window.lastDigits.length : 0;
                        survivalLabel = ` | Survival: warming up (${n}/${minDigits})`;
                    }

                    document.getElementById('ai-digit-score').textContent =
                        `Score: ${(best.score * 100).toFixed(1)}% | P10: ${(best.P10 * 100).toFixed(1)}%${sourceLabel}${survivalLabel}`;

                    // Color code based on score
                    const scoreElem = document.getElementById('ai-digit-score');
                    scoreElem.classList.remove('engine-digit-score-high', 'engine-digit-score-medium', 'engine-digit-score-low');
                    if (best.score >= 0.85) scoreElem.classList.add('engine-digit-score-high');
                    else if (best.score >= 0.75) scoreElem.classList.add('engine-digit-score-medium');
                    else scoreElem.classList.add('engine-digit-score-low');

                    // Update survival panel (top3)
                    try {
                        const panel = document.getElementById('survival-top3');
                        if (panel) {
                            if (!hasSurvival) {
                                panel.textContent = 'Survival picks: warming upâ€¦';
                            } else if (!survivalTop3.length) {
                                panel.textContent = 'Survival picks: N/A';
                            } else {
                                panel.textContent = 'Top picks: ' + survivalTop3.map(x =>
                                    `${x.digit} (pm5:${Math.round((x.pm5 || 0) * 100)}%, pm10:${Math.round((x.pm10 || 0) * 100)}%, s20:${Math.round((x.s20 || 0) * 100)}%, etm:${Number.isFinite(x.etm) ? x.etm.toFixed(1) : 'âˆž'})`
                                ).join(' | ');
                            }
                        }
                    } catch (_) {}

                    log(`ðŸŽ¯ AI recommends digit ${best.digit} (Score: ${(best.score * 100).toFixed(1)}%, P10: ${(best.P10 * 100).toFixed(1)}%)`, 'AI');
                }
            },
            
            // Get digit statistics for display
            getDigitStatsForDisplay: function() {
                const stats = [];
                for (let d = 0; d < 10; d++) {
                    const s = this.digitStats[d];
                    stats.push({
                        digit: d,
                        count: s.count,
                        currentGap: s.currentGap,
                        avgGap: s.avgGap.toFixed(1),
                        p90Gap: s.p90Gap,
                        persistenceScore: s.persistenceScore,
                        isUnstable: s.isUnstable,
                        isRecommended: Array.isArray(this.currentRecommendations) ? this.currentRecommendations.some(r => r && r.digit === d) : (this.currentRecommendation && this.currentRecommendation.digit === d)
                    });
                }
                return stats;
            }
        };
        
        
        // ============================================================================
        // SURVIVAL CURVE ENGINE v1
        // Empirical conditional survival from historical gaps (rolling digits)
        // ============================================================================
        const SurvivalEngine = (() => {
          function clampDigit(x) {
            x = Number(x);
            if (!Number.isFinite(x)) return null;
            x = Math.floor(x);
            return (x >= 0 && x <= 9) ? x : null;
          }

          function buildGapSamples(digits) {
            const lastSeen = Array(10).fill(null);
            const gaps = Array.from({ length: 10 }, () => []);
            for (let i = 0; i < digits.length; i++) {
              const d = clampDigit(digits[i]);
              if (d === null) continue;
              if (lastSeen[d] !== null) gaps[d].push(i - lastSeen[d] - 1);
              lastSeen[d] = i;
            }
            return gaps;
          }

          function computeCurrentGaps(digits) {
            const lastSeen = Array(10).fill(null);
            for (let i = 0; i < digits.length; i++) {
              const d = clampDigit(digits[i]);
              if (d === null) continue;
              lastSeen[d] = i;
            }
            const n = digits.length;
            return lastSeen.map(idx => (idx === null ? n : (n - 1 - idx)));
          }

          function percentile(arr, p) {
            if (!arr.length) return 0;
            const a = [...arr].sort((x, y) => x - y);
            const idx = (p / 100) * (a.length - 1);
            const lo = Math.floor(idx), hi = Math.ceil(idx);
            if (lo === hi) return a[lo];
            return a[lo] + (a[hi] - a[lo]) * (idx - lo);
          }

          function survivalConditional(gaps, g, t) {
            const eligible = gaps.filter(x => x > g);
            if (!eligible.length) return 1.0;
            const stillWaiting = eligible.filter(x => x > g + t);
            return stillWaiting.length / eligible.length;
          }

          function pMatchWithin(gaps, g, k) {
            return 1 - survivalConditional(gaps, g, k);
          }

          function expectedAdditionalTicks(gaps, g) {
            const eligible = gaps.filter(x => x > g);
            if (!eligible.length) return Infinity;
            const rem = eligible.map(x => x - g);
            return rem.reduce((s, x) => s + x, 0) / rem.length;
          }

          function analyze(lastDigits, opts = {}) {
            const window = opts.window ?? 2000;
            const digits = lastDigits.slice(-window);

            const gapsByDigit = buildGapSamples(digits);
            const currentGaps = computeCurrentGaps(digits);

            const out = [];
            for (let d = 0; d <= 9; d++) {
              const gaps = gapsByDigit[d];
              const g = currentGaps[d];

              const p90 = percentile(gaps, 90);
              const p75 = percentile(gaps, 75);
              const avg = gaps.length ? (gaps.reduce((s,x)=>s+x,0)/gaps.length) : 0;

              const pm5  = pMatchWithin(gaps, g, 5);
              const pm10 = pMatchWithin(gaps, g, 10);

              const s10 = survivalConditional(gaps, g, 10);
              const s20 = survivalConditional(gaps, g, 20);

              const etm = expectedAdditionalTicks(gaps, g);

              const inPressure = (p90 > 0) ? (g >= 0.70 * p90 && g < 0.95 * p90) : false;

              out.push({ digit: d, gap: g, avgGap: avg, p75, p90, inPressure, pm5, pm10, s10, s20, etm });
            }
            return out;
          }

          function rank(stats, cfg = {}) {
            const minPm5 = cfg.minPm5 ?? 0.60;
            const maxS20 = cfg.maxS20 ?? 0.25;
            const maxETM = cfg.maxETM ?? 12;
            const requirePressure = cfg.requirePressure ?? true;

            const candidates = stats.filter(x => {
              if (requirePressure && !x.inPressure) return false;
              if (x.pm5 < minPm5) return false;
              if (x.s20 > maxS20) return false;
              if (x.etm > maxETM) return false;
              return true;
            });

            candidates.forEach(x => {
              x.survivalScore =
                (2.0 * x.pm5) +
                (1.0 * x.pm10) -
                (2.5 * x.s20) -
                (0.05 * Math.min(x.etm, 100));
            });

            candidates.sort((a, b) => b.survivalScore - a.survivalScore);
            return candidates;
          }

          return { analyze, rank };
        })();

        window.SurvivalEngine = SurvivalEngine;

// ============================================================================
        // MARTINGALE CALCULATOR FUNCTIONS
        // ============================================================================
        
        let calculatorExpanded = true;
        
        function toggleCalculator() {
            calculatorExpanded = !calculatorExpanded;
            const calculatorContent = document.getElementById('calculatorContent');
            const toggleIcon = document.getElementById('calcToggleIcon');
            
            if (calculatorExpanded) {
                calculatorContent.classList.remove('hidden');
                toggleIcon.textContent = 'âˆ’';
            } else {
                calculatorContent.classList.add('hidden');
                toggleIcon.textContent = '+';
            }
        }
        
        function calculateMartingale() {
            try {
                const baseStake = parseFloat(document.getElementById('calc_base_stake').value) || 1.0;
                const multiplier = parseFloat(document.getElementById('calc_multiplier').value) || 1.15;
                const maxTrades = parseInt(document.getElementById('calc_max_trades').value) || 10;
                const bankrollLimit = parseFloat(document.getElementById('calc_bankroll_limit').value) || 50.0;
                
                if (baseStake <= 0 || multiplier <= 1.0 || maxTrades <= 0) {
                    alert('Please enter valid values for calculation.');
                    return;
                }
                
                let currentStake = baseStake;
                let totalRequired = 0;
                let progression = [];
                let finalStake = baseStake;
                
                // Calculate progression and totals
                for (let i = 1; i <= maxTrades; i++) {
                    if (i === 1) {
                        currentStake = baseStake;
                    } else {
                        currentStake *= multiplier;
                    }
                    
                    // Round to 2 decimal places
                    currentStake = Math.round(currentStake * 100) / 100;
                    totalRequired += currentStake;
                    finalStake = currentStake;
                    
                    progression.push({
                        trade: i,
                        stake: currentStake.toFixed(2),
                        cumulative: Math.round(totalRequired * 100) / 100
                    });
                }
                
                // Round total required
                totalRequired = Math.round(totalRequired * 100) / 100;
                
                // Calculate profit on win (DIGITMATCH pays 9x)
                const profitOnWin = (finalStake * 9) - totalRequired;
                
                // Update main bot controls with calculated values
                document.getElementById('baseStake').value = baseStake.toFixed(2);
                document.getElementById('multiplier').value = multiplier.toFixed(2);
                document.getElementById('maxTrades').value = maxTrades;
                
                // Update calculator results
                document.getElementById('calc_total_required').textContent = `$${totalRequired.toFixed(2)}`;
                document.getElementById('calc_final_stake').textContent = `$${finalStake.toFixed(2)}`;
                document.getElementById('calc_profit_on_win').textContent = `$${profitOnWin.toFixed(2)}`;
                
                // Update bankroll status
                const bankrollStatusElem = document.getElementById('calc_bankroll_status');
                bankrollStatusElem.classList.remove('calculator-safe', 'calculator-warning', 'calculator-highlight');
                
                if (totalRequired <= bankrollLimit) {
                    bankrollStatusElem.textContent = 'âœ… Within Limit';
                    bankrollStatusElem.classList.add('calculator-safe');
                } else if (totalRequired <= bankrollLimit * 1.5) {
                    bankrollStatusElem.textContent = 'âš ï¸ Close to Limit';
                    bankrollStatusElem.classList.add('calculator-warning');
                } else {
                    bankrollStatusElem.textContent = 'âŒ Over Limit';
                    bankrollStatusElem.classList.add('calculator-warning');
                }
                
                // Update progression display
                const progressionElem = document.getElementById('calc_progression');
                let progressionHTML = '<div class="grid grid-cols-4 gap-1 text-xs mb-1 font-semibold text-gray-300">';
                progressionHTML += '<div>Trade #</div><div>Stake</div><div>Cumulative</div><div>Status</div>';
                progressionHTML += '</div>';
                
                progression.forEach(item => {
                    const status = item.cumulative <= bankrollLimit ? 'âœ…' : 'âŒ';
                    progressionHTML += `
                        <div class="grid grid-cols-4 gap-1 text-xs py-1 ${item.trade % 2 === 0 ? 'bg-gray-800/50' : ''}">
                            <div class="text-gray-300">${item.trade}</div>
                            <div class="text-green-400">$${item.stake}</div>
                            <div class="text-blue-400">$${item.cumulative.toFixed(2)}</div>
                            <div class="${status === 'âœ…' ? 'text-green-400' : 'text-red-400'}">${status}</div>
                        </div>
                    `;
                });
                
                progressionElem.innerHTML = progressionHTML;
                
                // Add pulse animation
                document.getElementById('calc_total_required').classList.add('calculator-pulse');
                setTimeout(() => {
                    document.getElementById('calc_total_required').classList.remove('calculator-pulse');
                }, 500);
                
                log(`ðŸ§® Calculator: Total required: $${totalRequired.toFixed(2)} for ${maxTrades} trades`, 'CALCULATOR');
                
            } catch (error) {
                console.error('Calculator error:', error);
                alert('Error in calculation. Please check your inputs.');
            }
        }
        
        function syncCalculatorWithMain() {
            const baseStake = parseFloat(document.getElementById('baseStake').value) || 1.0;
            const multiplier = parseFloat(document.getElementById('multiplier').value) || 1.15;
            const maxTrades = parseInt(document.getElementById('maxTrades').value) || 10;
            
            document.getElementById('calc_base_stake').value = baseStake.toFixed(2);
            document.getElementById('calc_multiplier').value = multiplier.toFixed(2);
            document.getElementById('calc_max_trades').value = maxTrades;
            
            // Auto-calculate when main controls change
            calculateMartingale();
        }
        
        // ============================================================================
        // ENGINE UI FUNCTIONS
        // ============================================================================
        
        function toggleEngine() {
            window.digitIntelligenceEngine.enabled = !window.digitIntelligenceEngine.enabled;
            updateEngineButton();
            
            log(`ðŸ§  Digit Intelligence Engine ${window.digitIntelligenceEngine.enabled ? 'ENABLED' : 'DISABLED'}`, 'ENGINE');
            
            if (window.digitIntelligenceEngine.enabled && window.isBotRunning && window.ws && window.ws.readyState === WebSocket.OPEN) {
                // Re-request warm-up if engine was re-enabled
                requestWarmupTicks();
            }
        }
        
        function updateEngineButton() {
            const indicator = document.getElementById('engineIndicator');
            if (!indicator) return;

            const isOn = !!window.digitIntelligenceEngine?.enabled && !!window.isBotRunning;
            indicator.classList.toggle('on', isOn);
            indicator.classList.toggle('off', !isOn);
            indicator.title = isOn ? 'AI Engine is ON' : 'AI Engine is OFF';
        }
        
        function updateEngineStatus(text, status, progress) {
            const badge = document.getElementById('engine-status-badge');
            const statusText = document.getElementById('engine-status-text');
            const progressElem = document.getElementById('engine-warmup-progress');
            
            if (badge) {
                badge.classList.remove('engine-status-warmup', 'engine-status-analyzing', 'engine-status-ready');
                
                switch(status) {
                    case 'WARMUP':
                        badge.textContent = 'ðŸ”¥ ENGINE: WARM-UP';
                        badge.classList.add('engine-status-warmup');
                        break;
                    case 'ANALYZING':
                        badge.textContent = 'ðŸ” ENGINE: ANALYZING';
                        badge.classList.add('engine-status-analyzing');
                        break;
                    case 'READY':
                        badge.textContent = 'âœ… ENGINE: READY';
                        badge.classList.add('engine-status-ready');
                        break;
                }
            }
            
            if (statusText) {
                statusText.textContent = text;
            }
            
            if (progressElem) {
                progressElem.textContent = `${progress}%`;
            }
        }
        
        function toggleDigitAnalysis() {
            const panel = document.getElementById('digit-analysis-panel');
            const toggle = document.getElementById('digit-analysis-toggle');
            
            if (panel.classList.contains('hidden')) {
                panel.classList.remove('hidden');
                toggle.textContent = 'â–²';
                updateDigitAnalysisDisplay();
            } else {
                panel.classList.add('hidden');
                toggle.textContent = 'â–¼';
            }
        }
        
        function updateDigitAnalysisDisplay() {
            const engine = window.digitIntelligenceEngine;
            const thresholds = window.AI_THRESHOLDS;
            const scoreCutoff = 0.50; // ranking hint only

            if (!engine.warmupDone) {
                document.getElementById('digit-analysis-content').innerHTML = `
                    <div class="text-center py-4">
                        <div class="text-yellow-400 mb-2">Engine warming up...</div>
                        <div class="text-xs text-gray-500">${engine.warmupTicks}/${engine.targetWarmupTicks} ticks analyzed</div>
                    </div>
                `;
                return;
            }

            const regimeStatus = engine.computeRegimeStatus();

            const baseMaxPersistence =
                regimeStatus.label === "STABLE"
                    ? thresholds.maxPersistenceStable
                    : thresholds.maxPersistenceUnstable;

            // SurvivalEngine top picks (if enough history)
            let survivalTop3 = [];
            try {
                if (window.SurvivalEngine && Array.isArray(window.lastDigits) && window.lastDigits.length >= 200) {
                    const sStats = window.SurvivalEngine.analyze(window.lastDigits, { window: window.SURVIVAL_WINDOW || 2000 });
                    survivalTop3 = window.SurvivalEngine.rank(sStats, window.SURVIVAL_CFG || {}).slice(0, 3);
                }
            } catch (e) {
                console.warn('SurvivalEngine display error:', e);
            }

            let html = `
                <div class="mb-3">
                    <div class="text-xs font-semibold text-gray-300 mb-1">Regime Status:</div>
                    <div class="text-xs ${regimeStatus.ok ? 'text-green-400' : 'text-yellow-400'}">
                        ${regimeStatus.label} | Entropy: ${regimeStatus.entropy} | Dominance: ${regimeStatus.dominance}
                    </div>
                    <div class="text-[11px] text-gray-500 mt-1">
                        Gates â€” Supportâ‰¥${thresholds.minSupport}, H5â‰¥${thresholds.minH5}, P10â‰¥${thresholds.minP10}, Pressureâˆˆ[${thresholds.pressureZoneMinP90Ratio}Ã—P90, ${thresholds.pressureZoneMaxP90Ratio}Ã—P90), Extendâ‰¤${thresholds.maxExtend},
                        Persistenceâ‰¤${baseMaxPersistence} (relaxâ†’${thresholds.maxPersistenceStableRelax}), Score(rank)â‰¥${(scoreCutoff * 100).toFixed(0)}%
                    </div>
                </div>
                ${survivalTop3.length ? `
                <div class="mb-3 p-2 bg-gray-800/60 rounded border border-cyan-500/30">
                    <div class="text-xs font-semibold text-cyan-300 mb-1">Survival Top Picks (fast + low tail-risk):</div>
                    ${survivalTop3.map((x, i) => `
                        <div class="text-[11px] text-gray-300 flex flex-wrap gap-x-3 gap-y-1">
                            <span class="text-cyan-200 font-bold">#${i + 1} Digit ${x.digit}</span>
                            <span>gap:${x.gap}</span>
                            <span>pm5:${Math.round(x.pm5 * 100)}%</span>
                            <span>pm10:${Math.round(x.pm10 * 100)}%</span>
                            <span>s20:${Math.round(x.s20 * 100)}%</span>
                            <span>etm:${Number.isFinite(x.etm) ? x.etm.toFixed(1) : 'âˆž'}</span>
                            <span class="text-gray-500">score:${x.survivalScore.toFixed(2)}</span>
                        </div>
                    `).join('')}
                </div>
                ` : `
                <div class="mb-3 text-[11px] text-gray-500">
                    Survival picks: none (need more history or no digit passes pm5/s20/etm + pressure).
                </div>
                `}
                <div class="grid grid-cols-1 gap-1">
            `;

            for (let d = 0; d < 10; d++) {
                const s = engine.digitStats[d];
                const g = s.currentGap;
                const support = s.gaps.length;

                const P5 = engine.conditionalReturnProb(d, g, 5);
                const P10 = engine.conditionalReturnProb(d, g, 10);

                const extendRatio = (s.avgGap && s.avgGap > 0) ? (g / s.avgGap) : Infinity;
                const effectiveMaxPersistence = (
                    regimeStatus.label === "STABLE" &&
                    P10 >= (thresholds.minP10 + 0.05) &&
                    extendRatio <= 1.3
                ) ? thresholds.maxPersistenceStableRelax : baseMaxPersistence;

                const p90 = Math.max(s.p90Gap, 1);
                const p90Ratio = g / p90;

                const passSupport = support >= thresholds.minSupport;
                const passP90 = !(thresholds.require_g_lt_p90 && g >= p90);
                const passPressure = !thresholds.pressureZoneEnabled || (
                    p90Ratio >= thresholds.pressureZoneMinP90Ratio &&
                    p90Ratio < thresholds.pressureZoneMaxP90Ratio
                );
                const passPersistence = s.persistenceScore <= effectiveMaxPersistence;
                const passExtend = s.consecutiveExtendingGaps <= thresholds.maxExtend;
                const passUnstable = !s.isUnstable;
                const passP5 = P5 >= thresholds.minH5;
                const passP10 = P10 >= thresholds.minP10;
const denom = Math.max(1 - thresholds.pressureZoneMinP90Ratio, 1e-6);
                const pressureScore = thresholds.pressureZoneEnabled
                    ? Math.max(0, Math.min(1, (p90Ratio - thresholds.pressureZoneMinP90Ratio) / denom))
                    : Math.max(0, Math.min(1, g / p90));

                const score =
                    0.45 * P10 +
                    0.25 * P5 +
                    0.20 * pressureScore +
                    0.10 * (1 - s.persistenceScore / 100);
const passScore = score >= scoreCutoff;

                const passAll =
                    passSupport && passP90 && passPressure && passPersistence && passExtend && passUnstable && passP5 && passP10;
const isRecommended = Array.isArray(engine.currentRecommendations)
                    ? engine.currentRecommendations.some(r => r && r.digit === d)
                    : (engine.currentRecommendation && engine.currentRecommendation.digit === d);

                const barWidth = Math.min(100, (g / 50) * 100);
                const barColor = !passAll ? 'bg-red-500' :
                                isRecommended ? 'bg-green-500' :
                                s.persistenceScore > 70 ? 'bg-yellow-500' :
                                g > s.p90Gap ? 'bg-orange-500' : 'bg-blue-500';

                const flag = (ok) => ok ? 'âœ…' : 'âŒ';

                html += `
                    <div class="p-1 ${isRecommended ? 'bg-green-900/30 rounded' : ''}">
                        <div class="flex justify-between items-center">
                            <div class="text-xs font-semibold ${isRecommended ? 'text-green-400' : 'text-gray-200'}">
                                Digit ${d} ${isRecommended ? 'â­' : ''}
                            </div>
                            <div class="text-[11px] text-gray-400">
                                Gap: <span class="text-gray-200">${g}</span> | P90: <span class="text-gray-200">${s.p90Gap}</span>
                            </div>
                        </div>

                        <div class="text-[11px] text-gray-400 mt-1 flex flex-wrap gap-x-3 gap-y-1">
                            <span>Support: <span class="text-gray-200">${support}</span></span>
                            <span>Count: <span class="text-gray-200">${s.count}</span></span>
                            <span>AvgGap: <span class="text-gray-200">${s.avgGap.toFixed(1)}</span></span>
                            <span>ExtendStreak: <span class="text-gray-200">${s.consecutiveExtendingGaps}</span></span>
                            <span>Unstable: <span class="text-gray-200">${s.isUnstable ? 'YES' : 'NO'}</span></span>
                        </div>

                        <div class="text-[11px] text-gray-400 mt-1 flex flex-wrap gap-x-3 gap-y-1">
                            <span>H5(P5): <span class="text-gray-200">${P5.toFixed(2)}</span></span>
                            <span>P10: <span class="text-gray-200">${P10.toFixed(2)}</span></span>
                            <span>Persistence: <span class="text-gray-200">${s.persistenceScore}</span> / ${effectiveMaxPersistence}</span>
                            <span>ExtendRatio(g/avg): <span class="text-gray-200">${Number.isFinite(extendRatio) ? extendRatio.toFixed(2) : 'âˆž'}</span></span>
                            <span>Score: <span class="text-gray-200">${(score * 100).toFixed(1)}%</span></span>
                        </div>

                        <div class="text-[11px] text-gray-500 mt-1">
                            Pass: Support${flag(passSupport)} Â· P90${flag(passP90)} Â· Pressure${flag(passPressure)} Â· Persist${flag(passPersistence)} Â· Extend${flag(passExtend)} Â· Stable${flag(passUnstable)} Â· H5${flag(passP5)} Â· P10${flag(passP10)} Â· Score${flag(passScore)}
                        </div>

                        <div class="mt-1 bg-gray-700/40 rounded h-2">
                            <div class="${barColor} h-2 rounded-full" style="width: ${barWidth}%"></div>
                        </div>
                    </div>
                `;
            }

            html += '</div>';
            document.getElementById('digit-analysis-content').innerHTML = html;
        }
        
        function useAIRecommendedDigit() {
            if (!(window.digitIntelligenceEngine.currentRecommendations && window.digitIntelligenceEngine.currentRecommendations[0]) && !window.digitIntelligenceEngine.currentRecommendation) {
                log('âŒ No AI recommendation available yet', 'ENGINE');
                alert('AI engine is still analyzing. Please wait for a recommendation.');
                return;
            }
            
            const recommendedDigit = (window.digitIntelligenceEngine.currentRecommendations && window.digitIntelligenceEngine.currentRecommendations[0])
                        ? window.digitIntelligenceEngine.currentRecommendations[0].digit
                        : window.digitIntelligenceEngine.currentRecommendation.digit;
            document.getElementById('predictedDigit').value = recommendedDigit;
            
            if (sessionState.sessionStarted) {
                const confirmChange = confirm(`AI recommends digit ${recommendedDigit}. Change current digit?`);
                if (confirmChange) {
                    sessionState.sessionDigit = recommendedDigit;
                    sessionState.manualOverride = true;
                    updateSessionDisplay();
                    log(`âœ… Digit changed to AI recommendation: ${recommendedDigit}`, 'ENGINE');
                }
            } else {
                sessionState.sessionDigit = recommendedDigit;
                sessionState.sessionStarted = true;
                sessionState.manualOverride = true;
                updateSessionDisplay();
                log(`âœ… Set digit to AI recommendation: ${recommendedDigit}`, 'ENGINE');
            }
        }
        
        // ============================================================================
        // MODIFIED WEB SOCKET FUNCTIONS FOR ENGINE INTEGRATION
        // ============================================================================
        
        function requestWarmupTicks() {
            if (!window.ws || window.ws.readyState !== WebSocket.OPEN) return;
            
            const symbol = document.getElementById('symbol').value;
            const count = window.digitIntelligenceEngine.targetWarmupTicks;
            
            // Reset engine before warm-up
            window.digitIntelligenceEngine.reset();
            
            sendRequest({
                ticks_history: symbol,
                count: count,
                end: "latest",
                style: "ticks",
                req_id: getNextReqId()
            });
            
            log(`ðŸ§  Requesting ${count} warm-up ticks for engine analysis`, 'ENGINE');
        }
        
        // ============================================================================
        // CORE BOT FUNCTIONS - UPDATED FOR 10 SECOND PNL DISPLAY & NETWORK RECOVERY
        // ============================================================================
        
        // Global State
        window.ws = null;
        window.req_id = 0;
        window.isBotRunning = false;
        window.isConnecting = false;
        window.soundEnabled = true;
        window.ToneInitialized = false;
        window.synth = null;
        
        // NETWORK RECOVERY SYSTEM
        window.networkRecoveryEnabled = true;
        window.reconnectionAttempts = 0;
        window.maxReconnectionAttempts = 5;
        window.reconnectionDelay = 2000;
        window.lastDisconnectTime = 0;
        window.autoReconnectTimer = null;
        
        // Trading State
        window.baseStake = 1.0;
        window.currentStake = 1.0;
        window.multiplier = 1.15;
        window.maxTrades = 20;
        window.maxCycleTrades = 10;
        window.cycleRotations = 0;
        window.tradeCount = 0;
        window.martingaleStep = 0;
        window.cycleLosses = 0;
        window.accountBalance = 0.0;
        window.startingBalance = 0.0;
        window.currentBalance = 0.0;
        window.netProfit = 0.0;
        
        // PnL Tracking - UPDATED TO 10 SECONDS
        window.pnlTracker = {
            totalInvestment: 0.0,
            totalPayout: 0.0,
            netProfit: 0.0,
            trades: []
        };
        
        // PnL Update Timer - INCREASED FROM 3 TO 10 SECONDS
        window.pnlUpdateInterval = null;
        window.pnlUpdateStartTime = 0;
        window.pnlUpdateDuration = 10000; // 10 seconds instead of 3
        
        // Execution State
        window.lastTick = null;
        window.nextTradeAllowed = true;
        window.stopAfterWin = false;
        window.pendingProposals = new Map();
        window.executionLock = false;
        
        // Statistics
        window.stats = {
            totalTicks: 0,
            tradesExecuted: 0,
            wins: 0,
            losses: 0
        };
        
        // Rate tracking
        window.botTickTimestamps = [];
        
        // Queue
        window.tickQueue = [];
        window.maxQueueSize = 30;
        
        // Session State
        let sessionState = {
            active: false,
            mode: 'instant', // Only instant and ai modes now
            sessionDigit: null,
            sessionStarted: false,
            manualOverride: false
        };
        
        // Tick tracking for connection status
        window.totalTicksReceived = 0;
        window.tickTimestamps = [];
        
        // Digit zero tracker - FOR DEBUGGING
        window.digitZeroTracker = {
            count: 0,
            lastPrice: null,
            occurrences: []
        };

        // Tick decimal auto-detection (preserves trailing zeros for correct digit counting)
        window.tickFormat = {
            decimals: 3,
            lastQuote: null,
            minStep: Infinity,
            symbol: null
        };

        function estimateDecimalsFromStep(step) {
            if (!Number.isFinite(step) || step <= 0) return window.tickFormat.decimals;
            const tolerance = 1e-6;
            for (let dec = 0; dec <= 6; dec++) {
                const scaled = step * Math.pow(10, dec);
                if (Math.abs(scaled - Math.round(scaled)) < tolerance) return dec;
            }
            return 6;
        }

        function updateTickFormatFromQuote(quote) {
            const q = Number(quote);
            if (!Number.isFinite(q)) return;

            if (window.tickFormat.lastQuote !== null) {
                const diff = Math.abs(q - window.tickFormat.lastQuote);
                if (diff > 0) {
                    window.tickFormat.minStep = Math.min(window.tickFormat.minStep, diff);
                    window.tickFormat.decimals = estimateDecimalsFromStep(window.tickFormat.minStep);
                }
            }
            window.tickFormat.lastQuote = q;
        }

        function initTickFormatFromPrices(prices) {
            let minStep = Infinity;
            for (let i = 1; i < prices.length; i++) {
                const a = Number(prices[i - 1]);
                const b = Number(prices[i]);
                if (!Number.isFinite(a) || !Number.isFinite(b)) continue;
                const diff = Math.abs(b - a);
                if (diff > 0) minStep = Math.min(minStep, diff);
            }
            if (Number.isFinite(minStep)) {
                window.tickFormat.minStep = minStep;
                window.tickFormat.decimals = estimateDecimalsFromStep(minStep);
            }
        }

        function formatQuoteForDigit(quote) {
            const q = Number(quote);
            if (!Number.isFinite(q)) return null;
            return q.toFixed(window.tickFormat.decimals);
        }

        function getLastDigitFromQuote(quote) {
            const s = formatQuoteForDigit(quote);
            if (!s) return NaN;
            const lastChar = s[s.length - 1];
            const d = Number.parseInt(lastChar, 10);
            return Number.isNaN(d) ? NaN : d;
        }

        
        // DOM Elements
        const toggleButton = document.getElementById('toggleButton');
        const soundToggleButton = document.getElementById('soundToggle');
        const networkRecoveryToggle = document.getElementById('networkRecoveryIndicator');
        const networkRecoveryBadge = document.getElementById('network-recovery-badge');
        const sessionDisplay = document.getElementById('session_display');
        const tradeResultContainer = document.getElementById('trade-result-container');
        const metricPreviousResult = document.getElementById('metricPreviousResult');
        const metricNextAction = document.getElementById('metricNextAction');
        const metricTradeResult = document.getElementById('metricTradeResult');
        const metricTotalProfit = document.getElementById('metricTotalProfit');
        
        // ============================================================================
        // NETWORK RECOVERY SYSTEM
        // ============================================================================
        
        function toggleNetworkRecovery() {
            window.networkRecoveryEnabled = !window.networkRecoveryEnabled;
            updateNetworkRecoveryButton();
            
            log(`ðŸ”„ Network auto-recovery ${window.networkRecoveryEnabled ? 'ENABLED' : 'DISABLED'}`, 'SYSTEM');
            
            if (window.networkRecoveryEnabled) {
                networkRecoveryBadge.classList.remove('hidden');
            } else {
                networkRecoveryBadge.classList.add('hidden');
                // Clear any pending reconnection attempts
                if (window.autoReconnectTimer) {
                    clearTimeout(window.autoReconnectTimer);
                    window.autoReconnectTimer = null;
                }
            }
        }
        
        function updateNetworkRecoveryButton() {
            const indicator = document.getElementById('networkRecoveryIndicator');
            if (!indicator) return;

            const isOn = !!window.networkRecoveryEnabled && !!window.isBotRunning;
            indicator.classList.toggle('on', isOn);
            indicator.classList.toggle('off', !isOn);
            indicator.title = isOn ? 'Auto-Recovery is ON' : 'Auto-Recovery is OFF';
        }
        
        function attemptNetworkRecovery() {
            if (!window.networkRecoveryEnabled || !window.isBotRunning) {
                return;
            }
            
            window.reconnectionAttempts++;
            
            if (window.reconnectionAttempts > window.maxReconnectionAttempts) {
                log(`âŒ Max reconnection attempts (${window.maxReconnectionAttempts}) reached. Stopping bot.`, 'NETWORK');
                stopBot();
                return;
            }
            
            const delay = window.reconnectionDelay * Math.pow(1.5, window.reconnectionAttempts - 1);
            
            log(`ðŸ”„ Network recovery attempt ${window.reconnectionAttempts}/${window.maxReconnectionAttempts} in ${delay/1000}s...`, 'NETWORK');
            
            updateTradeStatus('RECONNECTING', 
                `Network recovery attempt ${window.reconnectionAttempts}/${window.maxReconnectionAttempts}`,
                `Reconnecting in ${delay/1000}s...`,
                'normal');
            
            window.autoReconnectTimer = setTimeout(() => {
                if (window.isBotRunning) {
                    log('ðŸ”— Attempting to reconnect WebSocket...', 'NETWORK');
                    connectWebSocket();
                }
            }, delay);
        }
        
        function resetReconnectionAttempts() {
            window.reconnectionAttempts = 0;
            if (window.autoReconnectTimer) {
                clearTimeout(window.autoReconnectTimer);
                window.autoReconnectTimer = null;
            }
        }
        
        // ============================================================================
        // PnL UPDATE FUNCTIONS - UPDATED FOR 10 SECOND DISPLAY
        // ============================================================================
        
        function startExtendedPnlUpdate(payout) {
            window.pnlUpdateStartTime = Date.now();
            
            // Clear any existing interval
            if (window.pnlUpdateInterval) {
                clearInterval(window.pnlUpdateInterval);
            }
            
            // Start with immediate update
            updatePnL();
            
            // Start continuous updates for 10 seconds
            window.pnlUpdateInterval = setInterval(() => {
                const elapsed = Date.now() - window.pnlUpdateStartTime;
                
                if (elapsed >= window.pnlUpdateDuration) {
                    // Stop after 10 seconds
                    clearInterval(window.pnlUpdateInterval);
                    window.pnlUpdateInterval = null;
                    log('ðŸ’° PnL update sequence completed (10 seconds)', 'PNL');
                    
                    // Final update
                    updatePnL();
                    
                    // Stop bot after PnL updates are complete
                    setTimeout(() => {
                        if (window.isBotRunning) {
                            stopBot();
                        }
                    }, 100);
                } else {
                    // Continue updating PnL with visual feedback
                    updatePnL();
                    
                    // Add visual pulse every 500ms
                    if (elapsed % 500 < 50) {
                        metricTotalProfit.classList.add('pnl-update-animation');
                        setTimeout(() => {
                            metricTotalProfit.classList.remove('pnl-update-animation');
                        }, 500);
                    }
                    
                    // Log progress every second
                    if (elapsed % 1000 < 50) {
                        const secondsLeft = Math.ceil((window.pnlUpdateDuration - elapsed) / 1000);
                        log(`ðŸ’° PnL updating... ${secondsLeft}s`, 'PNL');
                    }
                }
            }, 100); // Update every 100ms for smooth animation
        }
        
        function updatePnL() {
            const pnlElem = document.getElementById('metricTotalProfit');
            
            if (window.startingBalance > 0 && window.currentBalance > 0) {
                window.netProfit = window.currentBalance - window.startingBalance;
                const formattedProfit = window.netProfit.toFixed(2);
                const isPositive = window.netProfit > 0;
                const isNegative = window.netProfit < 0;
                
                pnlElem.textContent = `${isPositive ? '+' : ''}$${formattedProfit}`;
                pnlElem.classList.remove('profit-positive', 'profit-negative', 'profit-neutral');
                
                if (isPositive) pnlElem.classList.add('profit-positive');
                else if (isNegative) pnlElem.classList.add('profit-negative');
                else pnlElem.classList.add('profit-neutral');
                
                return window.netProfit;
            }
            
            if (window.pnlTracker.totalPayout > 0 || window.pnlTracker.totalInvestment > 0) {
                window.netProfit = window.pnlTracker.totalPayout - window.pnlTracker.totalInvestment;
                const formattedProfit = window.netProfit.toFixed(2);
                const isPositive = window.netProfit > 0;
                const isNegative = window.netProfit < 0;
                
                pnlElem.textContent = `${isPositive ? '+' : ''}$${formattedProfit}`;
                pnlElem.classList.remove('profit-positive', 'profit-negative', 'profit-neutral');
                
                if (isPositive) pnlElem.classList.add('profit-positive');
                else if (isNegative) pnlElem.classList.add('profit-negative');
                else pnlElem.classList.add('profit-neutral');
                
                return window.netProfit;
            }
            
            pnlElem.textContent = '$0.00';
            pnlElem.classList.remove('profit-positive', 'profit-negative');
            pnlElem.classList.add('profit-neutral');
            return 0;
        }
        
        function trackTradeInvestment(amount) {
            window.pnlTracker.totalInvestment += parseFloat(amount);
            window.pnlTracker.trades.push({
                type: 'investment',
                amount: parseFloat(amount),
                timestamp: Date.now()
            });
            updatePnL();
            log(`ðŸ’° Investment tracked: $${amount.toFixed(2)}`, 'PNL');
        }
        
        function trackTradePayout(amount) {
            window.pnlTracker.totalPayout += parseFloat(amount);
            window.pnlTracker.trades.push({
                type: 'payout',
                amount: parseFloat(amount),
                timestamp: Date.now()
            });
            updatePnL();
            log(`ðŸ’° Payout tracked: $${amount.toFixed(2)}`, 'PNL');
        }
        
        function resetPnL() {
            window.pnlTracker = { totalInvestment: 0.0, totalPayout: 0.0, netProfit: 0.0, trades: [] };
            window.startingBalance = 0.0;
            window.currentBalance = 0.0;
            window.netProfit = 0.0;
            
            if (window.pnlUpdateInterval) {
                clearInterval(window.pnlUpdateInterval);
                window.pnlUpdateInterval = null;
            }
            
            updatePnL();
            log('ðŸ’° PnL reset', 'PNL');
        }
        
        // ============================================================================
        // CORE BOT FUNCTIONS CONTINUED
        // ============================================================================
        
        // Check for authentication token
        function checkAuthToken() {
            const token = localStorage.getItem('active_token') || localStorage.getItem('derivToken');
            if (!token) {
                log('âš ï¸ No API token found. Please authenticate first.', 'WARNING');
                return false;
            }
            return true;
        }
        
        // Initialize account toggle
        function initializeToggleState() {
            const token = localStorage.getItem('active_token');
            const allAccounts = JSON.parse(localStorage.getItem('deriv_accounts')) || [];
            
            if (token && allAccounts.length > 0) {
                const currentAccount = allAccounts.find(acc => acc.token === token);
                if (currentAccount) {
                    const isReal = !currentAccount.account.startsWith('VR');
                    document.getElementById('accTypeToggle').checked = isReal;
                    log(`Account: ${isReal ? 'REAL' : 'DEMO'} (${currentAccount.account})`, 'SYSTEM');
                }
            }
        }
        
        // Switch account
        function switchAccount() {
            const isRealRequested = document.getElementById('accTypeToggle').checked;
            const allAccounts = JSON.parse(localStorage.getItem('deriv_accounts')) || [];
            
            const targetAccount = allAccounts.find(acc => 
                isRealRequested ? !acc.account.startsWith('VR') : acc.account.startsWith('VR')
            );
        
            if (targetAccount) {
                localStorage.setItem('active_token', targetAccount.token);
                log(`Switched to ${isRealRequested ? 'REAL' : 'DEMO'} account`, 'SYSTEM');
                
                if (window.isBotRunning) {
                    stopBot();
                    setTimeout(() => startBot(), 1000);
                }
            } else {
                alert(`No ${isRealRequested ? 'Real' : 'Demo'} account found`);
                document.getElementById('accTypeToggle').checked = !isRealRequested;
            }
        }
        
        // TRADE STATUS UI FUNCTIONS
        function updateTradeStatus(status, result, action, type = 'normal') {
            tradeResultContainer.classList.remove('win-glow');
            metricPreviousResult.textContent = result;
            metricNextAction.textContent = action;
            
            switch(type) {
                case 'win':
                    metricTradeResult.textContent = 'WIN ðŸŽ¯';
                    metricTradeResult.className = 'text-xs font-bold status-win';
                    metricPreviousResult.className = 'text-sm font-bold status-win';
                    metricNextAction.className = 'text-sm font-bold text-green-400';
                    tradeResultContainer.classList.add('win-glow');
                    log(`ðŸŽ¯ Trade Status: ${result}`, 'WIN');
                    break;
                case 'loss':
                    metricTradeResult.textContent = 'LOSS âŒ';
                    metricTradeResult.className = 'text-xs font-bold status-loss';
                    metricPreviousResult.className = 'text-sm font-bold status-loss';
                    metricNextAction.className = 'text-sm font-bold text-red-400';
                    log(`âŒ Trade Status: ${result}`, 'LOSS');
                    break;
                case 'trade':
                    metricTradeResult.textContent = 'TRADING âš¡';
                    metricTradeResult.className = 'text-xs font-bold status-trade';
                    metricPreviousResult.className = 'text-sm font-bold status-trade';
                    metricNextAction.className = 'text-sm font-bold text-yellow-400';
                    log(`âš¡ Trade Status: ${result}`, 'TRADE');
                    break;
                default:
                    metricTradeResult.textContent = status || 'READY';
                    metricTradeResult.className = 'text-xs font-bold text-gray-400';
                    metricPreviousResult.className = 'text-sm font-bold text-gray-300';
                    metricNextAction.className = 'text-sm font-bold text-yellow-400';
                    break;
            }
        }
        
        function resetTradeStatus() {
            updateTradeStatus('READY', 'Waiting for connection...', 'Start bot to begin', 'normal');
        }
        
        // SESSION MANAGEMENT
        function updateSessionDisplay() {
            const digitEl = document.getElementById('session_digit');
            const tradesEl = document.getElementById('session_trades');

            const isAI = sessionState.mode === 'ai';
            const recs = window.digitIntelligenceEngine?.currentRecommendations;

            let digitText = '-';
            if (isAI && Array.isArray(recs) && recs.length >= 2 && Number.isInteger(recs[0]?.digit) && Number.isInteger(recs[1]?.digit)) {
                digitText = `A:${recs[0].digit} | B:${recs[1].digit}`;
            } else if (sessionState.sessionDigit !== null && sessionState.sessionDigit !== undefined) {
                digitText = String(sessionState.sessionDigit);
            }

            const shouldShow = (isAI && window.isBotRunning) || (sessionState.sessionStarted && sessionState.sessionDigit !== null);

            if (shouldShow) {
                digitEl.textContent = digitText;
                tradesEl.textContent = `${window.tradeCount}/${window.maxTrades}`;
                sessionDisplay.classList.remove('hidden');
            } else {
                sessionDisplay.classList.add('hidden');
            }
        }
        
        function lockSessionDigit(digit, force = false, reason = '') {
            if (!force && sessionState.sessionStarted && sessionState.sessionDigit !== null) {
                log(`ðŸ”’ Digit ${digit} is already locked for this session`, 'SESSION');
                return sessionState.sessionDigit;
            }

            sessionState.sessionDigit = digit;
            sessionState.sessionStarted = true;
            sessionState.manualOverride = false;
            document.getElementById('predictedDigit').value = digit;
            updateSessionDisplay();
            log(`ðŸ”’ Digit ${digit} locked for current session${reason ? ' (' + reason + ')' : ''}`, 'SESSION');
            return digit;
        }

        function clearSessionDigitLock(reason = '') {
            sessionState.sessionDigit = null;
            sessionState.sessionStarted = false;
            sessionState.manualOverride = false;
            updateSessionDisplay();
            if (reason) log(`ðŸ”“ Session digit lock cleared (${reason})`, 'SESSION');
        }

        // HYBRID UTILITIES (tail-risk gate + cycle rotation)
        function getSurvivalForDigit(digit) {
            const d = Number(digit);
            if (!Number.isFinite(d) || d < 0 || d > 9) return null;

            if (window.latestSurvivalByDigit && window.latestSurvivalByDigit[d]) {
                return window.latestSurvivalByDigit[d];
            }

            const rec = window.digitIntelligenceEngine?.currentRecommendation;
            if (rec && rec.digit === d && rec.survival) return rec.survival;

            return null;
        }

        function pickBestLowTailRiskDigit(maxS20 = 0.05) {
            if (!window.latestSurvivalByDigit) return null;

            let best = null;
            for (let d = 0; d <= 9; d++) {
                const s = window.latestSurvivalByDigit[d];
                if (!s) continue;

                const s20 = Number(s.s20);
                if (!Number.isFinite(s20) || s20 > maxS20) continue;

                const raw =
                    (2.0 * (s.pm5 || 0)) +
                    (1.0 * (s.pm10 || 0)) -
                    (2.5 * (s.s20 || 0)) -
                    (0.05 * Math.min(Number.isFinite(s.etm) ? s.etm : 100, 100));

                const norm = 1 / (1 + Math.exp(-raw));
                if (!best || norm > best.norm) best = { digit: d, norm, s };
            }
            return best;
        }

        function getS20ThresholdFraction() {
            const el = document.getElementById('s20Threshold');
            const pct = el ? parseFloat(el.value) : NaN;
            if (!Number.isFinite(pct)) return 0.05;
            return Math.max(0, pct) / 100;
        }

        function getDigitS20(digit) {
            const s = window.latestSurvivalByDigit?.[digit];
            const v = Number(s?.s20);
            return Number.isFinite(v) ? v : null;
        }

        function rotateHybridDigit(reason = '') {
            clearSessionDigitLock(reason || 'Rotate');
            window.cycleRotations = (window.cycleRotations || 0) + 1;

            // Reset progression (cycle reset)
            window.martingaleStep = 0;
            window.currentStake = window.baseStake;

            if (sessionState.mode !== 'ai') return;

            // Prefer a low tail-risk digit (s20 <= 5%), otherwise use current AI rec.
            const pick = pickBestLowTailRiskDigit(getS20ThresholdFraction());
            const nextDigit =
                (pick && Number.isFinite(pick.digit)) ? pick.digit :
                (window.digitIntelligenceEngine?.currentRecommendation?.digit ?? null);

            if (nextDigit === null) return;

            lockSessionDigit(nextDigit, true, reason || 'Rotate');
            log(`ðŸ” Re-picked HYBRID digit ${nextDigit}${reason ? ' (' + reason + ')' : ''}`, 'SESSION');
        }



// CONNECTION STATUS
        function updateConnectionStatus() {
            const isConnected = window.ws && window.ws.readyState === WebSocket.OPEN;
            const isConnecting = window.isConnecting || false;
            
            if (isConnected) {
                document.getElementById('status-badge').textContent = 'ðŸŸ¢ CONNECTED';
                document.getElementById('status-badge').className = 'ml-3 inline-flex items-center px-3 py-1 text-sm font-medium rounded-full connection-badge-connected text-white shadow-md';
                document.getElementById('market_status').textContent = 'Live';
                document.getElementById('market_status').className = 'ml-2 font-bold text-green-400';
                updateTradeStatus('CONNECTED', 'Market live - Ready to trade', 'Set parameters and start trading', 'normal');
            } else if (isConnecting) {
                document.getElementById('status-badge').textContent = 'ðŸŸ¡ CONNECTING';
                document.getElementById('status-badge').className = 'ml-3 inline-flex items-center px-3 py-1 text-sm font-medium rounded-full connection-badge-connecting text-white shadow-md';
                document.getElementById('market_status').textContent = 'Connecting...';
                document.getElementById('market_status').className = 'ml-2 font-bold text-yellow-400';
                updateTradeStatus('CONNECTING', 'Connecting to market...', 'Please wait', 'normal');
            } else {
                document.getElementById('status-badge').textContent = 'ðŸ”´ DISCONNECTED';
                document.getElementById('status-badge').className = 'ml-3 inline-flex items-center px-3 py-1 text-sm font-medium rounded-full connection-badge-disconnected text-white shadow-md';
                document.getElementById('market_status').textContent = 'Offline';
                document.getElementById('market_status').className = 'ml-2 font-bold text-red-400';
                updateTradeStatus('DISCONNECTED', 'Market offline', 'Start bot to connect', 'normal');
            }
            
            document.getElementById('current_symbol').textContent = 
                document.getElementById('symbol').options[document.getElementById('symbol').selectedIndex].text;
            
            document.getElementById('ticks_received').textContent = window.totalTicksReceived;
            
            // Update tick rate
            const now = Date.now();
            const recentTicks = window.tickTimestamps.filter(ts => now - ts < 5000);
            const tickRate = recentTicks.length / 5;
            document.getElementById('current_tick_rate').textContent = tickRate.toFixed(1) + '/s';
        }
        
        // MODE MANAGEMENT - ONLY INSTANT AND AI AUTO
        function switchMode(mode) {
            sessionState.mode = mode;
            
            // Reset button colors
            document.getElementById('mode_instant').classList.remove('bg-green-600', 'bg-purple-600');
            document.getElementById('mode_ai').classList.remove('bg-green-600', 'bg-purple-600');
            
            if (mode === 'instant') {
                document.getElementById('mode_instant').classList.add('bg-green-600');
                document.getElementById('mode_ai').classList.add('bg-purple-600');
                document.getElementById('mode_description').textContent = 'âš¡ INSTANT: Trade on each tick with manual digit';
                log('ðŸ”„ Switched to INSTANT mode', 'SYSTEM');
                window.nextTradeAllowed = true;
                
                if (window.isBotRunning && !sessionState.manualOverride) {
                    const manualDigit = parseInt(document.getElementById('predictedDigit').value);
                    if (!isNaN(manualDigit) && manualDigit >= 0 && manualDigit <= 9) {
                        sessionState.sessionDigit = manualDigit;
                        sessionState.sessionStarted = true;
                        sessionState.manualOverride = true;
                        updateSessionDisplay();
                        log(`ðŸ”’ Digit ${manualDigit} set manually for instant mode`, 'SESSION');
                    }
                }
            } else if (mode === 'ai') {
                document.getElementById('mode_ai').classList.add('bg-green-600');
                document.getElementById('mode_instant').classList.add('bg-purple-600');
                document.getElementById('mode_description').textContent = 'ðŸ¤– AI AUTO: Let AI select and lock the current prediction when started';
                log('ðŸ”„ Switched to AI AUTO mode', 'SYSTEM');

                // In AI mode we PREVIEW digits while stopped, and LOCK only when the bot is running.
                if (window.digitIntelligenceEngine.warmupDone && (window.digitIntelligenceEngine.currentRecommendations || window.digitIntelligenceEngine.currentRecommendation)) {
                    const recommendedDigit = (window.digitIntelligenceEngine.currentRecommendations && window.digitIntelligenceEngine.currentRecommendations[0])
                        ? window.digitIntelligenceEngine.currentRecommendations[0].digit
                        : window.digitIntelligenceEngine.currentRecommendation.digit;
                    document.getElementById('predictedDigit').value = recommendedDigit;

                    if (window.isBotRunning) {
                        lockSessionDigit(recommendedDigit, true, 'AI AUTO (running)');
                        log(`ðŸ¤– AI mode active - Locked digit for trading: ${recommendedDigit}`, 'ENGINE');
                    } else {
                        clearSessionDigitLock('AI AUTO (preview)');
                        log(`ðŸ¤– AI mode active - Preview digit: ${recommendedDigit} (will lock on START)`, 'ENGINE');
                        updateTradeStatus('READY', `AI digit ${recommendedDigit} ready`, 'Will lock on Start', 'normal');
                    }
                } else {
                    clearSessionDigitLock('AI AUTO (waiting)');
                    log('ðŸ¤– AI mode active - Waiting for engine recommendation...', 'ENGINE');
                    updateTradeStatus('WAITING', 'AI engine analyzing...', 'Waiting for AI recommendation', 'normal');
                }
            }
            
            updateExecutionLogic();
        }
        
        function updateExecutionLogic() {
            if (sessionState.mode === 'ai') {
                const hasRec = !!window.digitIntelligenceEngine.currentRecommendation;
                const warmed = !!window.digitIntelligenceEngine.warmupDone;

                if (!warmed || !hasRec) {
                    if (window.isBotRunning) {
                        log('ðŸ§  AI Engine not ready yet...', 'ENGINE');
                        window.nextTradeAllowed = false;
                        updateTradeStatus('WAITING', 'AI Engine warming up', 'Waiting for AI recommendation', 'normal');
                    } else {
                        window.nextTradeAllowed = false;
                        clearSessionDigitLock('AI not ready (stopped)');
                        updateTradeStatus('WAITING', 'AI engine analyzing...', 'Will lock on Start when ready', 'normal');
                    }
                    return;
                }

                const recommendedDigit = (window.digitIntelligenceEngine.currentRecommendations && window.digitIntelligenceEngine.currentRecommendations[0])
                ? window.digitIntelligenceEngine.currentRecommendations[0].digit
                : window.digitIntelligenceEngine.currentRecommendation.digit;

                if (!window.isBotRunning) {
                    // Preview only while stopped
                    document.getElementById('predictedDigit').value = recommendedDigit;
                    clearSessionDigitLock('AI preview (stopped)');
                    window.nextTradeAllowed = false;
                    updateTradeStatus('READY', `AI digit ${recommendedDigit} ready`, 'Will lock on Start', 'normal');
                    return;
                }

                // Bot is running: lock ONCE (at start) and do NOT overwrite after lock.
                if (!sessionState.sessionStarted || sessionState.sessionDigit === null) {
                    lockSessionDigit(recommendedDigit, true, 'START lock');
                    updateTradeStatus('READY', `AI digit ${recommendedDigit} locked`, 'Ready to trade', 'normal');
                } else {
                    // Keep the locked digit for trading
                    updateTradeStatus('READY', `Digit ${sessionState.sessionDigit} locked`, 'Trading locked session digit', 'normal');
                }

                window.nextTradeAllowed = true;
                return;
            }

            if (sessionState.mode === 'instant') {
                window.nextTradeAllowed = true;
                updateTradeStatus('READY', 'Instant mode active', 'Trading on each tick', 'normal');
            }
        }

// DOM Ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ðŸ¤– Bot initialized');
            initializeToggleState();
            
            // Initialize intelligence engine
            window.digitIntelligenceEngine.init();
            
            // Initialize network recovery
            updateNetworkRecoveryButton();
            
            // Initialize engine button
            updateEngineButton();
            
            if (!checkAuthToken()) {
                document.getElementById('prediction_text').textContent = 'Please authenticate first';
            }
            
            setInterval(calculateRates, 1000);
            startQueueProcessor();
            
            // Update digit analysis display periodically
            setInterval(() => {
                if (!document.getElementById('digit-analysis-panel').classList.contains('hidden')) {
                    updateDigitAnalysisDisplay();
                }
            }, 2000);
            
            calculateMartingale();
            
            document.getElementById('baseStake').addEventListener('change', syncCalculatorWithMain);
            document.getElementById('multiplier').addEventListener('change', syncCalculatorWithMain);
            document.getElementById('maxTrades').addEventListener('change', syncCalculatorWithMain);
            document.getElementById('calc_base_stake').addEventListener('change', () => {
                document.getElementById('baseStake').value = document.getElementById('calc_base_stake').value;
            });
            document.getElementById('calc_multiplier').addEventListener('change', () => {
                document.getElementById('multiplier').value = document.getElementById('calc_multiplier').value;
            });
            document.getElementById('calc_max_trades').addEventListener('change', () => {
                document.getElementById('maxTrades').value = document.getElementById('calc_max_trades').value;
            });
            
            log('ðŸ¤– Bot ready', 'SYSTEM');
            switchMode('instant');
            updatePnL();
            resetTradeStatus();
            
            document.getElementById('predictedDigit').addEventListener('change', function() {
                const newDigit = parseInt(this.value);
                if (!isNaN(newDigit) && newDigit >= 0 && newDigit <= 9) {
                    
                    if (sessionState.sessionStarted) {
                        const confirmChange = confirm('âš ï¸ Changing digit will reset current session. Continue?');
                        if (!confirmChange) {
                            this.value = sessionState.sessionDigit || 5;
                            return;
                        }
                    }
                    
                    sessionState.sessionDigit = newDigit;
                    sessionState.sessionStarted = true;
                    sessionState.manualOverride = true;
                    updateSessionDisplay();
                    log(`ðŸ”¢ Digit manually set to ${newDigit}`, 'SESSION');
                    updateTradeStatus('MANUAL', `Digit manually set to ${newDigit}`, 'Ready to trade', 'normal');
                }
            });
            
            // Test digit extraction
            testDigitExtraction();
        });
        
        // Test function for digit extraction
        function testDigitExtraction() {
            // Test cases including digit 0
            const testPrices = [
                '1234.560', // ends with 0
                '987.650',  // ends with 0
                '1234.567',
                '987.654',
                '1000.000', // all zeros
                '999.990'   // ends with 0
            ];
            
            console.log('=== Testing Digit Extraction ===');
            testPrices.forEach(price => {
                const priceStr = String(price);
                const lastChar = priceStr[priceStr.length - 1];
                const digit = parseInt(lastChar);
                console.log(`Price: ${price}, Last char: "${lastChar}", Digit: ${digit}, Valid: ${!isNaN(digit)}`);
            });
        }
        
        // WEBSOCKET CONNECTION - UPDATED WITH NETWORK RECOVERY
        function connectWebSocket() {
            if (window.ws) {
                try {
                    window.ws.close();
                } catch (e) {}
            }
            
            window.isConnecting = true;
            updateConnectionStatus();
            
            const wsUrl = 'wss://ws.binaryws.com/websockets/v3?app_id=120389';
            log('ðŸ”— Connecting to Deriv API...', 'SYSTEM');
            
            window.ws = new WebSocket(wsUrl);
            
            window.ws.onopen = () => {
                window.isConnecting = false;
                resetReconnectionAttempts();
                log('âœ… WebSocket connected', 'SYSTEM');
                updateConnectionStatus();
                
                const token = localStorage.getItem('active_token') || localStorage.getItem('derivToken');
                if (!token) {
                    log('âŒ No API token found in storage', 'ERROR');
                    stopBot();
                    return;
                }
                
                sendRequest({ 
                    authorize: token, 
                    req_id: getNextReqId() 
                });
            };
            
            window.ws.onmessage = (msg) => {
                try {
                    const data = JSON.parse(msg.data);
                    console.log('API Response:', data.msg_type, data); // Debug logging
                    
                    // ðŸ”¥ CRITICAL FIX: Handle tick messages
                    if (data.msg_type === 'tick') {
                        console.log('Tick received:', data.tick); // Debug
                        
                        // Log specifically for digit 0
                        updateTickFormatFromQuote(data.tick.quote);
                        const digit = getLastDigitFromQuote(data.tick.quote);
                        if (digit === 0) {
                            console.log('ðŸŽ¯ DIGIT 0 DETECTED in formatted tick:', formatQuoteForDigit(data.tick.quote));
                        }
                        
                        handleTick(data.tick);
                        return;
                    }
                    
                    handleAPIResponse(data);
                } catch (e) {
                    console.error('WebSocket message error:', e);
                    log('âŒ Error parsing WebSocket message', 'ERROR');
                }
            };
            
            window.ws.onclose = () => {
                window.isConnecting = false;
                updateConnectionStatus();
                log('ðŸ”Œ WebSocket disconnected', 'SYSTEM');
                
                if (window.isBotRunning) {
                    window.lastDisconnectTime = Date.now();
                    
                    // Attempt automatic reconnection if enabled
                    if (window.networkRecoveryEnabled) {
                        attemptNetworkRecovery();
                    } else {
                        log('âš ï¸ Network recovery disabled. Manual restart required.', 'NETWORK');
                        updateTradeStatus('DISCONNECTED', 'WebSocket disconnected', 'Click START to reconnect', 'normal');
                    }
                }
            };
            
            window.ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                log('âŒ WebSocket connection error', 'ERROR');
                updateTradeStatus('ERROR', 'WebSocket connection failed', 'Check network connection', 'loss');
            };
        }
        
        // ============================================================================
        // âœ… FIXED: TICK HANDLER - PROPER DIGIT EXTRACTION INCLUDING DIGIT 0
        // ============================================================================
        
        // TICK HANDLER - FIXED DIGIT EXTRACTION (SPECIAL FIX FOR DIGIT 0)
        function handleTick(tick) {
            if (!window.isBotRunning || !tick || !tick.quote) return;
            
            const price = parseFloat(tick.quote);
            
            // Digit extraction using auto-detected decimals (preserves trailing zeros)
            updateTickFormatFromQuote(tick.quote);
            const digit = getLastDigitFromQuote(tick.quote);
            
            // Debug logging for digit 0
            if (digit === 0) {
                console.log('Digit 0 detected:', tick.quote, 'Formatted:', formatQuoteForDigit(tick.quote));
            }
            
            if (isNaN(digit) || digit < 0 || digit > 9) {
                log(`âš ï¸ Invalid digit from tick: ${tick.quote}`, 'WARNING');
                return;
            }
            
            // Track digit 0 occurrences for debugging
            if (digit === 0) {
                window.digitZeroTracker.count++;
                window.digitZeroTracker.lastPrice = price;
                window.digitZeroTracker.occurrences.push({
                    price: price,
                    time: Date.now(),
                    tickData: tick
                });
                
                // Log to console for debugging
                console.log(`ðŸŽ¯ DIGIT 0 FOUND! Total: ${window.digitZeroTracker.count}, Price: ${price}`);
                
                // Also update a debug display if needed
                if (window.digitZeroTracker.count % 10 === 0) {
                    log(`ðŸ”¢ Digit 0 has appeared ${window.digitZeroTracker.count} times`, 'DEBUG');
                }
            }
            
            const tickData = { 
                digit: digit, 
                price: price, 
                time: Date.now(),
                raw: tick
            };
            
            window.lastTick = tickData;
            
            // Update UI - show the digit clearly
            document.getElementById('metricLiveTick').textContent = price.toFixed(3);
            document.getElementById('metricLastDigit').textContent = `Digit: ${digit}`;
            document.getElementById('metricLiveTick').classList.add('tick-flash');
            setTimeout(() => document.getElementById('metricLiveTick').classList.remove('tick-flash'), 50);
            
            window.stats.totalTicks++;
            window.botTickTimestamps.push(Date.now());
            
            // Track ticks for connection status
            window.totalTicksReceived++;
            window.tickTimestamps.push(Date.now());
            const tenSecondsAgo = Date.now() - 10000;
            window.tickTimestamps = window.tickTimestamps.filter(ts => ts > tenSecondsAgo);
            
            // Add tick to queue for processing
            addTickToQueue(tickData);
            
            // Update engine with digit
            if (window.digitIntelligenceEngine.enabled) {
                window.digitIntelligenceEngine.processLiveTick(digit);
            }
            
            playAudioFeedback('TICK');
            
            // Update connection status UI
            updateConnectionStatus();
        }
        
        // API RESPONSE HANDLER - MODIFIED FOR ENGINE INTEGRATION
        function handleAPIResponse(data) {
            if (data.error) {
                log(`API Error: ${data.error.message}`, 'ERROR');
                if (data.error.code === 'InvalidToken') {
                    log('âŒ Invalid API Token. Please check your authentication.', 'CRITICAL');
                    stopBot();
                }
                return;
            }
        
            if (data.msg_type === 'authorize') {
                if (data.authorize) {
                    log(`ðŸ” Authorized as ${data.authorize.loginid}`, 'SYSTEM');
                    subscribeToTicks(document.getElementById('symbol').value);
                    subscribeToBalance();
                    
                    // Request warm-up ticks for engine
                    if (window.digitIntelligenceEngine.enabled) {
                        setTimeout(() => {
                            requestWarmupTicks();
                        }, 1000);
                    }
                }
            } else if (data.msg_type === 'history') {
                // Process warm-up ticks for engine
                if (window.digitIntelligenceEngine.enabled && data.history && data.history.prices) {
                    window.digitIntelligenceEngine.processWarmupTicks(data.history.prices);
                    log(`ðŸ§  Processed ${data.history.prices.length} warm-up ticks`, 'ENGINE');
                }
            
            } else if (data.msg_type === 'proposal') {
                handleProposalResponse(data.proposal, data.req_id);
            } else if (data.msg_type === 'buy') {
                handleBuyResponse(data.buy);
            } else if (data.msg_type === 'balance') {
                handleBalanceUpdate(data.balance);
            }
        }
        
        // Add tick to queue
        function addTickToQueue(tick) {
            window.tickQueue.push(tick);
            if (window.tickQueue.length > window.maxQueueSize) {
                window.tickQueue.shift();
            }
            
            return true;
        }
        
        // PROCESS TICK IMMEDIATELY - CRITICAL TRADE EXECUTION FUNCTION
        function processTickImmediately(tick) {
            if (window.stopAfterWin) return;
            
            // In AI mode, wait for engine recommendation
            if (sessionState.mode === 'ai' && (!window.digitIntelligenceEngine.warmupDone || !(window.digitIntelligenceEngine.currentRecommendations && window.digitIntelligenceEngine.currentRecommendations.length))) {
                log('ðŸ¤– Waiting for AI recommendation...', 'ENGINE');
                return;
            }
            
            // AI AUTO: lock the CURRENT prediction for trading when the bot is running (once per START)
            if (sessionState.mode === 'ai' && window.isBotRunning && (!sessionState.sessionStarted || sessionState.sessionDigit === null)) {
                const d = (window.digitIntelligenceEngine.currentRecommendations && window.digitIntelligenceEngine.currentRecommendations[0])
                    ? window.digitIntelligenceEngine.currentRecommendations[0].digit
                    : window.digitIntelligenceEngine.currentRecommendation.digit;
                lockSessionDigit(d, true, 'AUTO start lock');
            }

            if (checkForImmediateWin(tick)) {
                return;
            }
            
            if (window.tradeCount >= window.maxTrades) {
                log(`ðŸ›‘ Max trades reached (${window.maxTrades})`, 'CRITICAL');
                updateTradeStatus('MAX TRADES', `Maximum trades reached (${window.maxTrades})`, 'Bot stopped', 'loss');
                stopBot();
                return;
            }


            // ðŸ§± HARD TAIL-RISK GATE (s20 <= 5%)
            if (sessionState.mode === 'ai' && window.isBotRunning) {
                const lockedDigit = (window.digitIntelligenceEngine.currentRecommendations && window.digitIntelligenceEngine.currentRecommendations[0])
                    ? window.digitIntelligenceEngine.currentRecommendations[0].digit
                    : ((sessionState.sessionDigit !== null) ? sessionState.sessionDigit : parseInt(document.getElementById('predictedDigit').value));
                const s = getSurvivalForDigit(lockedDigit);

                if (!s || !Number.isFinite(Number(s.s20))) {
                    log('ðŸ§± Tail-risk gate: Survival data not ready â€” no trade', 'ENGINE');
                    updateTradeStatus('NO TRADE', 'Survival warming up', 'Waiting for more ticks', 'loss');
                    return;
                }

                const s20 = Number(s.s20);
                const maxS20 = getS20ThresholdFraction();
                if (s20 > maxS20) {
                    log(`ðŸ§± Tail-risk gate: s20 ${(s20 * 100).toFixed(1)}% > ${(maxS20 * 100).toFixed(1)}% â€” re-picking`, 'ENGINE');
                    updateTradeStatus('NO TRADE', `Tail risk too high (s20 ${(s20 * 100).toFixed(1)}% > ${(maxS20 * 100).toFixed(1)}%)`, 'Re-picking safer digit', 'loss');
                    rotateHybridDigit('Tail-risk gate');
                    return;
                }
            }
            
            window.executionLock = true;
            window.nextTradeAllowed = false;
            
            try {
                if (sessionState.mode === 'ai') {
                    // AI entry: dual if 2 distinct digits exist, otherwise single.
                    executeAiEntry(tick);
                } else {
                    window.stats.tradesExecuted++;
                    window.tradeCount++;
                    document.getElementById('metricTradeCount').textContent = window.tradeCount;

                    updateSessionDisplay();
                    log(`âš¡ Trade #${window.tradeCount}: ${tick.price.toFixed(3)} (Digit ${tick.digit})`, 'TRADE');

                    updateTradeStatus(
                        'TRADING',
                        `Trade #${window.tradeCount}: $${window.currentStake.toFixed(2)} on digit ${parseInt(document.getElementById('predictedDigit').value)}`,
                        'Executing trade...',
                        'trade'
                    );

                    playAudioFeedback('EXECUTION');
                    executeTrade(tick);
                }
                
            } catch (error) {
                log(`âŒ Error: ${error}`, 'ERROR');
                window.executionLock = false;
                window.nextTradeAllowed = true;
                updateTradeStatus('ERROR', `Trade failed: ${error}`, 'Retrying...', 'loss');
            }
        }
        
        
        // ============================================================================
        // DUAL-TRADE EXECUTION ENGINE (TOP-2 DIGITS)
        // - Stakes alternate per cycleIndex: A uses (step*2), B uses (step*2+1)
        // - Stop-on-first-win resets the cycleIndex
        // - Safety filter prevents execution if either digit is outside release band
        // ============================================================================
        let cycleIndex = 0;

        function resetCycle() {
            cycleIndex = 0;
        }

        function isValidDigit(digit) {
            const d = Number(digit);
            if (!Number.isFinite(d) || d < 0 || d > 9) return false;

            const engine = window.digitIntelligenceEngine;
            if (!engine || !engine.warmupDone) return false;

            const thresholds = window.AI_THRESHOLDS || {};
            const s = engine.digitStats?.[d];
            if (!s) return false;

            const g = Number(s.currentGap);
            const p90 = Math.max(Number(s.p90Gap) || 0, 1);
            const p90Ratio = g / p90;

            const minRatio = (typeof thresholds.pressureZoneMinFloorP90Ratio === "number") ? thresholds.pressureZoneMinFloorP90Ratio : 0.0;
            const maxRatio = (typeof thresholds.pressureZoneMaxP90Ratio === "number") ? thresholds.pressureZoneMaxP90Ratio : 1.0;

            if (thresholds.require_g_lt_p90 && g >= p90) return false;
            if (thresholds.pressureZoneEnabled) {
                if (p90Ratio < minRatio) return false;
                if (p90Ratio >= maxRatio) return false;
            }
            return true;
        }

        function onTradeResult(result) {
            if (result && result.status === 'won') {
                log('ðŸ›‘ Win detected â€” stopping bot immediately', 'WIN');
                updateTradeStatus('WIN ðŸŽ¯', 'Win detected', 'Bot stopped after win', 'win');
                window.stopAfterWin = true;
                stopBot();
                return;
            }
        }

        function placeDigitMatchTrade(digit, stake, tick) {
            const contractType = document.getElementById('contractType').value;
            const symbol = document.getElementById('symbol').value;

            const d = Number(digit);
            if (!Number.isFinite(d) || d < 0 || d > 9) return;

            const amount = Number(stake);
            if (!Number.isFinite(amount) || amount <= 0) return;

            trackTradeInvestment(amount);

            const proposalRequest = {
                proposal: 1,
                amount: amount.toFixed(2),
                basis: "stake",
                contract_type: contractType,
                currency: "USD",
                duration: 1,
                duration_unit: "t",
                symbol: symbol,
                barrier: String(Math.floor(d)),
                req_id: getNextReqId()
            };

            window.pendingProposals.set(proposalRequest.req_id, {
                tick: tick,
                stake: amount,
                contractType: contractType,
                predictedDigit: Math.floor(d),
                startTime: Date.now(),
                tradeNumber: window.tradeCount,
                martingaleStep: window.martingaleStep,
                dual: true
            });

            sendRequest(proposalRequest);
        }

        
        function executeAiEntry(tick) {
            const engine = window.digitIntelligenceEngine;
            const recs = engine?.currentRecommendations || [];
            const best = recs[0]?.digit ?? engine?.currentRecommendation?.digit;

            // Prefer dual only when we truly have 2 distinct digits.
            if (recs.length >= 2) {
                const d1 = recs[0]?.digit;
                const d2 = recs[1]?.digit;
                if (isValidDigit(d1) && isValidDigit(d2) && d1 !== d2) {
                    // executeDualTrade does its own S20 checks for both digits.
                    executeDualTrade(tick);
                    return;
                }
            }

            // Fallback to single-digit AI trade.
            if (!isValidDigit(best)) return;

            // Keep UI in sync
            document.getElementById('predictedDigit').value = best;

            sessionState.sessionStarted = true;
            sessionState.sessionDigit = best;
            updateSessionDisplay();

            // Max-trades guard (single trade)
            const maxTrades = parseInt(document.getElementById('maxTrades').value) || 10;
            if (window.tradeCount >= maxTrades) {
                log(`ðŸ›‘ Max trades reached (${maxTrades})`, 'CRITICAL');
                updateTradeStatus('MAX TRADES', `Maximum trades reached (${maxTrades})`, 'Bot stopped', 'loss');
                stopBot();
                return;
            }

            window.stats.tradesExecuted++;
            window.tradeCount++;
            document.getElementById('metricTradeCount').textContent = window.tradeCount;

            log(`âš¡ Trade #${window.tradeCount}: $${window.currentStake.toFixed(2)} on digit ${best}`, 'TRADE');
            updateTradeStatus(
                'TRADING',
                `Trade #${window.tradeCount}: $${window.currentStake.toFixed(2)} on digit ${best}`,
                'Executing trade...',
                'trade'
            );

            playAudioFeedback('EXECUTION');
            executeTrade(tick);
        }

function executeDualTrade(tick) {
            const maxTrades = parseInt(document.getElementById('maxTrades').value) || 10;

            if (window.tradeCount >= maxTrades) {
                log(`ðŸ›‘ Max trades reached (${maxTrades})`, 'CRITICAL');
                updateTradeStatus('MAX TRADES', `Maximum trades reached (${maxTrades})`, 'Bot stopped', 'loss');
                stopBot();
                return;
            }

            // Dual trades consume 2 trades per cycle.
            if ((window.tradeCount + 2) > maxTrades) {
                log(`ðŸ›‘ Not enough remaining trades for a dual entry (${window.tradeCount}/${maxTrades})`, 'CRITICAL');
                updateTradeStatus('MAX TRADES', `Remaining trades < 2 (${window.tradeCount}/${maxTrades})`, 'Bot stopped', 'loss');
                stopBot();
                return;
            }

            const recs = window.digitIntelligenceEngine?.currentRecommendations;
            if (!recs || recs.length < 2) return;

            const digitA = recs[0]?.digit;
            const digitB = recs[1]?.digit;

            if (!isValidDigit(digitA)) return;
            if (!isValidDigit(digitB)) return;

            // Require TWO DISTINCT digits before trading.
            if (digitA === digitB) return;

            // Show BOTH digits in the Active Session panel.
            sessionState.sessionStarted = true;
            sessionState.sessionDigit = `${digitA},${digitB}`;
// Tail-risk gate (S20) must pass for BOTH digits.
            const maxS20 = getS20ThresholdFraction();
            const s20A = getDigitS20(digitA);
            const s20B = getDigitS20(digitB);
            if (s20A === null || s20A > maxS20) return;
            if (s20B === null || s20B > maxS20) return;

            const baseStake = parseFloat(document.getElementById('baseStake').value) || 1.0;
            const multiplier = parseFloat(document.getElementById('multiplier').value) || 1.15;

            const stakeA = +(baseStake * Math.pow(multiplier, cycleIndex)).toFixed(2);
            const stakeB = +(stakeA * multiplier).toFixed(2);

            // Count this as ONE cycle step but TWO trades.
            window.stats.tradesExecuted += 2;
            window.tradeCount += 2;
            document.getElementById('metricTradeCount').textContent = window.tradeCount;

            if (window.tradeCount >= maxTrades) {
                log(`ðŸ›‘ Max trades reached (${maxTrades})`, 'CRITICAL');
                updateTradeStatus('MAX TRADES', `Maximum trades reached (${maxTrades})`, 'Bot stopped', 'loss');
                stopBot();
                return;
            }

            updateSessionDisplay();

            log(`âš¡ Dual Trade cycle ${cycleIndex + 1}: A(${digitA}) $${stakeA.toFixed(2)} | B(${digitB}) $${stakeB.toFixed(2)}`, 'TRADE');
            updateTradeStatus(
                'TRADING',
                `Dual: A $${stakeA.toFixed(2)} @${digitA} | B $${stakeB.toFixed(2)} @${digitB}`,
                'Executing dual trades.',
                'trade'
            );

            playAudioFeedback('EXECUTION');

            placeDigitMatchTrade(digitA, stakeA, tick);
            placeDigitMatchTrade(digitB, stakeB, tick);

            cycleIndex++;
        }

// EXECUTE TRADE - CRITICAL FUNCTION
        function executeTrade(tick) {
            const contractType = document.getElementById('contractType').value;
            const symbol = document.getElementById('symbol').value;
            const predictedDigit = parseInt(document.getElementById('predictedDigit').value);
            
            let stake = window.currentStake;
            trackTradeInvestment(stake);
            
            const proposalRequest = {
                proposal: 1,
                amount: stake.toFixed(2),
                basis: "stake",
                contract_type: contractType,
                currency: "USD",
                duration: 1,
                duration_unit: "t",
                symbol: symbol,
                barrier: predictedDigit.toString(),
                req_id: getNextReqId()
            };
            
            window.pendingProposals.set(proposalRequest.req_id, {
                tick: tick,
                stake: stake,
                contractType: contractType,
                predictedDigit: predictedDigit,
                startTime: Date.now(),
                tradeNumber: window.tradeCount,
                martingaleStep: window.martingaleStep
            });
            
            sendRequest(proposalRequest);
        }
        
        // CHECK FOR IMMEDIATE WIN - CRITICAL FUNCTION
        function checkForImmediateWin(tick) {
            if (!window.isBotRunning || window.stopAfterWin) return false;
            
            const predictedDigit = parseInt(document.getElementById('predictedDigit').value);
            const tickDigit = parseInt(tick.digit);
            
            if (tickDigit === predictedDigit) {
                log(`ðŸŽ¯ IMMEDIATE WIN! Digit ${tickDigit} matches ${predictedDigit}`, 'WIN');
                
                window.lastTradeResult = 'win';
                window.stopAfterWin = true;
                if (sessionState.mode === 'ai') { resetCycle(); }
                stopBot();
                window.stats.wins++;
                window.tradeCount++;
                
                playAudioFeedback('WIN');
                
                const payout = window.currentStake * 9;
                trackTradePayout(payout);
                log(`ðŸ’° Payout: $${payout.toFixed(2)}`, 'PNL');
                
                // Start extended PnL updates for 10 seconds
                startExtendedPnlUpdate(payout);
                
                updateTradeStatus(
                    'IMMEDIATE WIN ðŸŽ¯',
                    `Digit ${tickDigit} matched! Payout: $${payout.toFixed(2)}`,
                    'PnL updating for 10 seconds...',
                    'win'
                );
                
                updateStake('win');
                return true;
            }
            
            return false;
        }
        
        // UPDATE STAKE - CRITICAL FUNCTION
        function updateStake(winOrLoss) {
            window.baseStake = parseFloat(document.getElementById('baseStake').value) || 1.0;
            window.multiplier = parseFloat(document.getElementById('multiplier').value) || 1.15;
            window.maxTrades = parseInt(document.getElementById('maxTrades').value) || 10;
            window.maxCycleTrades = parseInt(document.getElementById('maxCycleTrades')?.value) || 10;
            
            if (winOrLoss === 'win') {
                window.martingaleStep = 0;
                window.cycleLosses = 0;
                window.currentStake = window.baseStake;
                log(`âœ… WIN! Reset stake: $${window.currentStake.toFixed(2)}`, 'WIN');
                
                const payout = window.currentStake * 9;
                trackTradePayout(payout);
                log(`ðŸ’° Payout: $${payout.toFixed(2)}`, 'PNL');
                
                // Start extended PnL updates for 10 seconds
                startExtendedPnlUpdate(payout);
                
                updateTradeStatus(
                    'WIN ðŸŽ¯',
                    `WON! Digit matched - Payout: $${payout.toFixed(2)}`,
                    'PnL updating for 10 seconds...',
                    'win'
                );
                
            } else if (winOrLoss === 'loss') {
                window.martingaleStep = (window.martingaleStep || 0) + 1;
                window.cycleLosses = (window.cycleLosses || 0) + 1;

                const newStake = window.currentStake * window.multiplier;
                window.currentStake = parseFloat(newStake.toFixed(2));

                if (window.cycleLosses >= window.maxCycleTrades) {
                    log(`ðŸ§¯ LOSS CAP REACHED (${window.maxCycleTrades}) â€” switching HYBRID digit (keeping martingale)`, 'CRITICAL');
                    updateTradeStatus(
                        'SWITCH DIGIT ðŸ”',
                        `Loss cap reached (${window.maxCycleTrades})`,
                        'Switching HYBRID digit; keeping martingale progression...',
                        'loss'
                    );

                    window.cycleLosses = 0;

                    if (window.isBotRunning && sessionState.mode === 'ai') {
                        rotateHybridDigit(`Loss cap ${window.maxCycleTrades} (keep martingale)`);
                    }
                }
                log(`âŒ LOSS. Next stake: $${window.currentStake.toFixed(2)} (Step: ${window.martingaleStep})`, 'LOSS');
                
                updateTradeStatus(
                    'LOSS âŒ',
                    `Lost - Next: $${window.currentStake.toFixed(2)}`,
                    'Increasing stake',
                    'loss'
                );
                
                // Always update PnL
                updatePnL();
                
            } else {
                window.martingaleStep = 0;
                window.cycleLosses = 0;
                window.currentStake = window.baseStake;
                log(`Starting. Base stake: $${window.currentStake.toFixed(2)}`, 'SYSTEM');
                updateTradeStatus('STARTING', `Base stake: $${window.currentStake.toFixed(2)}`, 'Waiting for trades', 'normal');
            }
            
            const stakeElem = document.getElementById('metricCurrentStake');
            stakeElem.textContent = `$${window.currentStake.toFixed(2)}`;
            stakeElem.className = winOrLoss === 'win' ? 'text-lg font-bold text-green-400' : 'text-lg font-bold text-white';
        }
        
        // START BOT - CRITICAL FUNCTION
        function startBot() {
            if (window.isBotRunning) {
                stopBot();
                return;
            }
            
            window.maxTrades = parseInt(document.getElementById('maxTrades').value) || 10;
            window.maxCycleTrades = parseInt(document.getElementById('maxCycleTrades')?.value) || 10;
            
            const token = localStorage.getItem('active_token') || localStorage.getItem('derivToken');
            if (!token) {
                log('âŒ No API token found. Please authenticate first.', 'CRITICAL');
                updateTradeStatus('ERROR', 'No API token found', 'Please authenticate first', 'loss');
                return;
            }
            
            resetAllState();
            
            // Initialize intelligence engine
            window.digitIntelligenceEngine.init();

            // Always re-lock using the CURRENT prediction when START is pressed.
            clearSessionDigitLock('Start');

            if (sessionState.mode === 'instant') {
                const manualDigit = parseInt(document.getElementById('predictedDigit').value);
                sessionState.sessionDigit = (Number.isFinite(manualDigit) && manualDigit >= 0 && manualDigit <= 9) ? manualDigit : 5;
                sessionState.sessionStarted = true;
                sessionState.manualOverride = true;
                updateSessionDisplay();
            } else {
                // AI mode: preview exists while stopped, but lock happens only after START when engine is ready.
                sessionState.manualOverride = false;
                sessionState.sessionStarted = false;
                sessionState.sessionDigit = null;
                updateSessionDisplay();
            }
window.isBotRunning = true;
            updateButtonState();
            
            log('ðŸš€ Starting bot...', 'SYSTEM');
            log(`ðŸ“Š Mode: ${sessionState.mode}`, 'SYSTEM');
            log(`ðŸ“Š Max Trades: ${window.maxTrades}`, 'SYSTEM');
            log(`ðŸ§¯ Max Cycle Trades: ${window.maxCycleTrades}`, 'SYSTEM');
            log(`ðŸ”‘ Using token: ${token.substring(0, 10)}...`, 'SYSTEM');
            log(`ðŸŒ Network auto-recovery: ${window.networkRecoveryEnabled ? 'ENABLED' : 'DISABLED'}`, 'SYSTEM');
            log(`ðŸ§  Digit Intelligence Engine: ${window.digitIntelligenceEngine.enabled ? 'ENABLED' : 'DISABLED'}`, 'SYSTEM');
            
            updateTradeStatus('STARTING', 'Initializing bot...', 'Connecting to market', 'normal');
            updateStake('initial');
            initTone();
            connectWebSocket();
            
            document.querySelectorAll('#symbol, #predictedDigit, #contractType, #baseStake, #multiplier, #maxTrades').forEach(control => {
                control.disabled = true;
                control.classList.add('opacity-50', 'cursor-not-allowed');
            });
            
            // Add connection verification
            setTimeout(() => {
                if (window.isBotRunning && (!window.ws || window.ws.readyState !== WebSocket.OPEN)) {
                    log('âŒ WebSocket failed to connect', 'ERROR');
                    updateTradeStatus('ERROR', 'WebSocket connection failed', 'Check network and API token', 'loss');
                }
            }, 3000);
        }
        
        // STOP BOT - CRITICAL FUNCTION
        function stopBot() {
            if (!window.isBotRunning) return;
            
            window.isBotRunning = false;
            window.nextTradeAllowed = false;
            window.stopAfterWin = false;
            updateButtonState();
            
            log('â¹ï¸ Bot stopped', 'SYSTEM');
            
            // Stop any ongoing PnL updates
            if (window.pnlUpdateInterval) {
                clearInterval(window.pnlUpdateInterval);
                window.pnlUpdateInterval = null;
            }
            
            // Stop any network recovery attempts
            resetReconnectionAttempts();
            
            if (window.ws) {
                window.ws.close();
                window.ws = null;
            }
            window.tickSubscriptionSent = false;
            window.pendingProposals.clear();
            window.executionLock = false;
            
            // Reset engine status
            updateEngineStatus('Inactive', 'WARMUP', 0);
            
            document.querySelectorAll('#symbol, #predictedDigit, #contractType, #baseStake, #multiplier, #maxTrades').forEach(control => {
                control.disabled = false;
                control.classList.remove('opacity-50', 'cursor-not-allowed');
            });
            
            updateConnectionStatus();
            
            // Ensure PnL is updated one more time before showing final status
            const finalPnL = updatePnL();
            log(`ðŸ’° Final PnL: ${finalPnL >= 0 ? '+' : ''}$${finalPnL.toFixed(2)}`, 'PNL');
            
            updateTradeStatus(
                'STOPPED',
                `Final PnL: ${finalPnL >= 0 ? '+' : ''}$${finalPnL.toFixed(2)}`,
                'Bot stopped - Ready for new session',
                finalPnL > 0 ? 'win' : 'normal'
            );
            
            sessionState.sessionStarted = false;
            sessionDisplay.classList.add('hidden');
        }
        
        function toggleBot() {
            if (window.isBotRunning) {
                stopBot();
            } else {
                startBot();
            }
        }
        
        // HELPER FUNCTIONS
        function calculateRates() {
            const now = Date.now();
            window.botTickTimestamps = window.botTickTimestamps.filter(ts => now - ts < 5000);
            const tickRate = window.botTickTimestamps.length / 5;
            document.getElementById('metricTickRate').textContent = `Ticks/sec: ${tickRate.toFixed(1)}`;
        }
        
        function toggleSound() {
            window.soundEnabled = !window.soundEnabled;
            localStorage.setItem('soundEnabled', window.soundEnabled);
            updateSoundButton();
            log(`ðŸ”Š Sound ${window.soundEnabled ? 'ON' : 'OFF'}`, 'SYSTEM');
        }
        
        function updateSoundButton() {
            if (!soundToggleButton) return;
            const isOn = !!window.soundEnabled;
            soundToggleButton.textContent = isOn ? 'ðŸ”Š' : 'ðŸ”‡';
            soundToggleButton.title = isOn ? 'Sound ON' : 'Sound OFF';
        }
        
        async function initTone() {
            if (!window.soundEnabled) return;
            
            if (typeof Tone === 'undefined') {
                console.error("Tone.js not loaded");
                return;
            }
            
            try {
                await Tone.start();
                window.synth = new Tone.Synth().toDestination();
                window.ToneInitialized = true;
            } catch (e) {
                console.error("Audio init error:", e);
            }
        }
        
        function playAudioFeedback(type) {
            if (!window.soundEnabled || !window.ToneInitialized || !window.synth) return;
            
            try {
                if (type === 'WIN') {
                    window.synth.triggerAttackRelease("C5", "8n");
                    setTimeout(() => window.synth.triggerAttackRelease("E5", "8n"), 100);
                    setTimeout(() => window.synth.triggerAttackRelease("G5", "8n"), 200);
                } else if (type === 'TICK') {
                    window.synth.triggerAttackRelease("C4", "32n", Tone.now(), 0.3);
                } else if (type === 'EXECUTION') {
                    window.synth.triggerAttackRelease("E5", "16n", Tone.now(), 0.5);
                }
            } catch (e) {
                console.error("Audio error:", e);
            }
        }
        
        function log(message, type = 'INFO') {
            const logArea = document.getElementById('log-area');
            const timestamp = new Date().toLocaleTimeString('en-US', { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit' 
            });
            
            let color = 'text-lime-400';
            if (type === 'ERROR') color = 'text-red-500 font-bold'; 
            if (type === 'WARNING') color = 'text-yellow-400';
            if (type === 'TRADE') color = 'text-green-300';
            if (type === 'WIN') color = 'text-green-400 font-bold';
            if (type === 'LOSS') color = 'text-red-400 font-bold';
            if (type === 'TICK') color = 'text-cyan-300';
            if (type === 'SYSTEM') color = 'text-white';
            if (type === 'PNL') color = 'text-purple-300 font-bold';
            if (type === 'SESSION') color = 'text-blue-300 font-bold';
            if (type === 'CALCULATOR') color = 'text-purple-300 font-bold';
            if (type === 'NETWORK') color = 'text-yellow-300 font-bold';
            if (type === 'ENGINE') color = 'text-purple-300 font-bold';
            if (type === 'DEBUG') color = 'text-gray-400 font-bold';
            
            logArea.innerHTML += `\n[${timestamp}] <span class="${color}">${message}</span>`;
            logArea.scrollTop = logArea.scrollHeight;
        }
        
        function updateButtonState() {
            if (!toggleButton) return;
            
            if (window.isBotRunning) {
                toggleButton.innerHTML = '<span class="flex items-center justify-center"><span class="mr-2">â¹ï¸</span> STOP BOT</span>';
                toggleButton.classList.remove('bg-green-600', 'hover:bg-green-700', 'start-button-active');
                toggleButton.classList.add('stop-button-active', 'hover:bg-red-700');
            } else {
                toggleButton.innerHTML = '<span class="flex items-center justify-center"><span class="mr-2">ðŸš€</span> START BOT</span>';
                toggleButton.classList.remove('stop-button-active', 'hover:bg-red-700');
                toggleButton.classList.add('bg-green-600', 'hover:bg-green-700', 'start-button-active');
            }
        
            try { updateEngineButton(); } catch(e) {}
            try { updateNetworkRecoveryButton(); } catch(e) {}
            try { updateSoundButton(); } catch(e) {}
        }
        
        // QUEUE PROCESSOR - CRITICAL FOR TRADE EXECUTION
        function startQueueProcessor() {
            setInterval(() => {
                if (!window.isBotRunning || window.stopAfterWin) return;
                
                while (window.tickQueue.length > 0 && !window.executionLock && window.nextTradeAllowed) {
                    const tick = window.tickQueue.shift();
                    processTickImmediately(tick);
                }
            }, 50);
        }
        
        function sendRequest(request) {
            if (window.ws && window.ws.readyState === WebSocket.OPEN) {
                const message = JSON.stringify(request);
                window.ws.send(message);
                return request.req_id;
            }
            return null;
        }
        
        function getNextReqId() {
            return ++window.req_id;
        }
        
        function subscribeToBalance() {
            sendRequest({ balance: 1, subscribe: 1, req_id: getNextReqId() });
            log('ðŸ’° Subscribed to balance', 'SYSTEM');
        }
        
        function handleBalanceUpdate(balanceData) {
            const newBalance = parseFloat(balanceData.balance);
            
            if (window.startingBalance === 0) {
                window.startingBalance = newBalance;
                log(`ðŸ’° Starting Balance: $${window.startingBalance.toFixed(2)}`, 'PNL');
            }
            
            window.currentBalance = newBalance;
            const balanceElem = document.getElementById('metricAccountBalance');
            balanceElem.textContent = `$${window.currentBalance.toFixed(2)}`;
            balanceElem.className = 'text-lg font-bold balance-green';
            updatePnL();
        }
        
        function subscribeToTicks(symbol) {
            if (window.tickSubscriptionSent) return;
            
            window.tickFormat.symbol = symbol;
            window.tickFormat.lastQuote = null;
            window.tickFormat.minStep = Infinity;
            window.tickFormat.decimals = window.tickFormat.decimals || 3;
            
            // Request tick stream
            sendRequest({ 
                ticks: symbol, 
                subscribe: 1, 
                req_id: getNextReqId() 
            });
            
            window.tickSubscriptionSent = true;
            log(`âœ… Subscribed to ${symbol} ticks`, 'SYSTEM');
            
            // Add verification
            setTimeout(() => {
                if (window.isBotRunning && window.totalTicksReceived === 0) {
                    log('âš ï¸ No ticks received. Checking connection...', 'WARNING');
                    updateConnectionStatus();
                }
            }, 2000);
        }
        
        function handleProposalResponse(proposal, req_id) {
            if (!proposal || !proposal.id) {
                log(`âŒ Proposal failed`, 'ERROR');
                updateTradeStatus('ERROR', 'Proposal failed', 'Retrying...', 'loss');
                return;
            }
        
            const pending = window.pendingProposals.get(req_id);
            if (!pending) return;
        
            window.pendingProposals.delete(req_id);
            executeBuy(proposal.id, proposal.ask_price, pending);
        }
        
        function executeBuy(proposal_id, ask_price, pending) {
            const buyRequest = {
                buy: proposal_id,
                price: ask_price,
                req_id: getNextReqId()
            };
            
            log(`âœ… Buying: $${pending.stake.toFixed(2)} on digit ${pending.predictedDigit}`, 'TRADE');
            
            window.pendingProposals.set(buyRequest.req_id, {
                ...pending,
                proposal_id: proposal_id,
                buyStartTime: Date.now()
            });
            
            sendRequest(buyRequest);
        }
        
        function handleBuyResponse(buyData) {
            if (buyData.contract_id) {
                log(`âœ… Trade executed successfully`, 'TRADE');
                
                // Check if this was a win or loss
                const wasWin = buyData.longcode && buyData.longcode.includes("win");
                
                try { onTradeResult({ status: wasWin ? 'won' : 'lost', buyData }); } catch (_) {}

                // Legacy single-trade stake progression (keep for INSTANT mode)
                if (sessionState.mode !== 'ai') {
                    updateStake(wasWin ? 'win' : 'loss');
                }

                onTradeComplete(true);
            } else {
                log(`âŒ Trade failed`, 'ERROR');
                updateTradeStatus('ERROR', 'Trade execution failed', 'Retrying...', 'loss');
                onTradeComplete(false);
            }
        }
        
        function onTradeComplete(isSuccess = true) {
            window.executionLock = false;
            window.nextTradeAllowed = true;
            updateSessionDisplay();
            
            if (!isSuccess) {
                updateStake('loss');
            }
            
            if (window.stopAfterWin) {
                return;
            }
            
            if (window.tradeCount >= window.maxTrades) {
                log(`ðŸ›‘ Max trades reached (${window.maxTrades})`, 'CRITICAL');
                updateTradeStatus('MAX TRADES', `Maximum trades reached (${window.maxTrades})`, 'Bot stopped', 'loss');
                stopBot();
                return;
            }
        }
        
        // Reset all state
        function resetAllState() {
            window.maxTrades = parseInt(document.getElementById('maxTrades').value) || 10;
            window.maxCycleTrades = parseInt(document.getElementById('maxCycleTrades')?.value) || 10;
            window.cycleRotations = 0;
            
            updateStake('initial');
            resetPnL();
            resetTradeStatus();
            
            window.startingBalance = 0.0;
            window.currentBalance = 0.0;
            window.netProfit = 0.0;
            
            document.getElementById('metricTradeCount').textContent = '0';
            document.getElementById('metricAccountBalance').textContent = '$---';
            document.getElementById('metricLiveTick').textContent = '---';
            document.getElementById('metricLastDigit').textContent = 'Digit: ?';
            
            window.stats = { totalTicks: 0, tradesExecuted: 0, wins: 0, losses: 0 };
            window.tickQueue = [];
            window.lastTick = null;
            window.lastTradeResult = null;
            window.tradeCount = 0;
            window.martingaleStep = 0;
            window.pendingProposals.clear();
            window.botTickTimestamps = [];
            
            window.executionLock = false;
            window.waitingForTradeResult = false;
            window.nextTradeAllowed = true;
            window.stopAfterWin = false;
            
            // Reset digit zero tracker
            window.digitZeroTracker = {
                count: 0,
                lastPrice: null,
                occurrences: []
            };
            
            const logArea = document.getElementById('log-area');
            logArea.innerHTML = '[00:00:00] ðŸ¤– Bot reset. Ready.';
            
            log('ðŸ”„ Bot reset', 'SYSTEM');
        }
    </script>
</body>
</html>
